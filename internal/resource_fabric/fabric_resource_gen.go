// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_fabric

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func FabricResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"alarms": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"critical": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"major": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"minor": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"warning": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: AlarmsType{
					ObjectType: types.ObjectType{
						AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^fabrics\\.eda\\.nokia\\.com/v1alpha1$"), ""),
				},
				Default: stringdefault.StaticString("fabrics.eda.nokia.com/v1alpha1"),
			},
			"deviations": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"count": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: DeviationsType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^Fabric$"), ""),
				},
				Default: stringdefault.StaticString("Fabric"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the Fabric",
				MarkdownDescription: "name of the Fabric",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"border_leafs": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"asn_pool": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
								MarkdownDescription: "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
							},
							"border_leaf_node_selector": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Label selector used to select Toponodes to configure as Borderleaf nodes.",
								MarkdownDescription: "Label selector used to select Toponodes to configure as Borderleaf nodes.",
							},
							"route_leaking": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"export_policy": schema.StringAttribute{
										Required:            true,
										Description:         "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
										MarkdownDescription: "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
									},
									"import_policy": schema.StringAttribute{
										Required:            true,
										Description:         "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
										MarkdownDescription: "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
									},
								},
								CustomType: RouteLeakingType{
									ObjectType: types.ObjectType{
										AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
								MarkdownDescription: "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
							},
							"system_pool_ipv4": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
							},
							"system_pool_ipv6": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
							},
						},
						CustomType: BorderLeafsType{
							ObjectType: types.ObjectType{
								AttrTypes: BorderLeafsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"fabric_selector": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Selects Fabric resources when connecting multiple Fabrics together. Only one Fabric needs the selector, typically the upper layer (e.g., Superspine) selecting the lower layer (e.g., a pod fabric of leafs and spines). This helps build complete Fabrics in smaller instances of the Fabric resource. This instance selecting other fabrics must also select the InterSwitchLinks connecting itself to the selected Fabrics.",
						MarkdownDescription: "Selects Fabric resources when connecting multiple Fabrics together. Only one Fabric needs the selector, typically the upper layer (e.g., Superspine) selecting the lower layer (e.g., a pod fabric of leafs and spines). This helps build complete Fabrics in smaller instances of the Fabric resource. This instance selecting other fabrics must also select the InterSwitchLinks connecting itself to the selected Fabrics.",
					},
					"inter_switch_links": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"ip_mtu": schema.Int64Attribute{
								Optional:            true,
								Description:         "Sets the IP MTU for the DefaultInterface.",
								MarkdownDescription: "Sets the IP MTU for the DefaultInterface.",
								Validators: []validator.Int64{
									int64validator.Between(1280, 9486),
								},
							},
							"link_selector": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Selects TopoLinks to include in this Fabric, creating an ISL resource if both Nodes in the TopoLink are part of this Fabric or a selected Fabric.",
								MarkdownDescription: "Selects TopoLinks to include in this Fabric, creating an ISL resource if both Nodes in the TopoLink are part of this Fabric or a selected Fabric.",
							},
							"pool_ipv4": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to DefaultInterfaces which are members of the ISLs.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack DefaultInterfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to DefaultInterfaces which are members of the ISLs.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack DefaultInterfaces.",
							},
							"pool_ipv6": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to DefaultInterfaces which are members of the ISLs.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack DefaultInterfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to DefaultInterfaces which are members of the ISLs.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack DefaultInterfaces.",
							},
							"qos": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"egress_policy": schema.StringAttribute{
										Optional: true,
									},
									"ingress_policy": schema.StringAttribute{
										Optional: true,
									},
								},
								CustomType: QosType{
									ObjectType: types.ObjectType{
										AttrTypes: QosValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"unnumbered": schema.StringAttribute{
								Optional:            true,
								Description:         "Enables unnumbered interfaces on the ISL; for IPv6, only link-local addresses are used unless a PoolIPV6 is also specified.  DefaultInterfaces in the ISL are added to the DefaultBGPPeer dynamic neighbor list when using an eBGP underlay.",
								MarkdownDescription: "Enables unnumbered interfaces on the ISL; for IPv6, only link-local addresses are used unless a PoolIPV6 is also specified.  DefaultInterfaces in the ISL are added to the DefaultBGPPeer dynamic neighbor list when using an eBGP underlay.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"IPV6",
									),
								},
							},
							"vlan_id": schema.Int64Attribute{
								Optional:            true,
								Description:         "Configures the provided VLAN on the DefaultInterfaces which are members of the ISLs.",
								MarkdownDescription: "Configures the provided VLAN on the DefaultInterfaces which are members of the ISLs.",
								Validators: []validator.Int64{
									int64validator.Between(1, 4094),
								},
							},
						},
						CustomType: InterSwitchLinksType{
							ObjectType: types.ObjectType{
								AttrTypes: InterSwitchLinksValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"leafs": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"asn_pool": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
								MarkdownDescription: "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
							},
							"leaf_node_selector": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Label selector used to select Toponodes to configure as Leaf nodes.",
								MarkdownDescription: "Label selector used to select Toponodes to configure as Leaf nodes.",
							},
							"route_leaking": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"export_policy": schema.StringAttribute{
										Required:            true,
										Description:         "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
										MarkdownDescription: "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
									},
									"import_policy": schema.StringAttribute{
										Required:            true,
										Description:         "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
										MarkdownDescription: "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
									},
								},
								CustomType: RouteLeaking1Type{
									ObjectType: types.ObjectType{
										AttrTypes: RouteLeaking1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
								MarkdownDescription: "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
							},
							"system_pool_ipv4": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
							},
							"system_pool_ipv6": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
							},
						},
						CustomType: LeafsType{
							ObjectType: types.ObjectType{
								AttrTypes: LeafsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"overlay_protocol": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"bfd": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"desired_min_transmit_int": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The minimum interval in microseconds between transmission of BFD control packets.",
										MarkdownDescription: "The minimum interval in microseconds between transmission of BFD control packets.",
										Validators: []validator.Int64{
											int64validator.Between(10000, 100000000),
										},
										Default: int64default.StaticInt64(1000000),
									},
									"detection_multiplier": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The number of packets that must be missed to declare this session as down.",
										MarkdownDescription: "The number of packets that must be missed to declare this session as down.",
										Validators: []validator.Int64{
											int64validator.Between(3, 20),
										},
										Default: int64default.StaticInt64(3),
									},
									"enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable Biforward Detection.",
										MarkdownDescription: "Enable Biforward Detection.",
										Default:             booldefault.StaticBool(false),
									},
									"min_echo_receive_interval": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The minimum interval between echo packets the local node can receive in microseconds.",
										MarkdownDescription: "The minimum interval between echo packets the local node can receive in microseconds.",
										Validators: []validator.Int64{
											int64validator.Between(0, 100000000),
										},
										Default: int64default.StaticInt64(1000000),
									},
									"required_min_receive": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The minimum interval in microseconds between received BFD control packets that this system should support.",
										MarkdownDescription: "The minimum interval in microseconds between received BFD control packets that this system should support.",
										Validators: []validator.Int64{
											int64validator.Between(10000, 100000000),
										},
										Default: int64default.StaticInt64(1000000),
									},
									"ttl": schema.Int64Attribute{
										Optional:            true,
										Description:         "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
										MarkdownDescription: "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
										Validators: []validator.Int64{
											int64validator.Between(2, 255),
										},
									},
								},
								CustomType: BfdType{
									ObjectType: types.ObjectType{
										AttrTypes: BfdValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Enable BFD on overlay protocol",
								MarkdownDescription: "Enable BFD on overlay protocol",
							},
							"bgp": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"autonomous_system": schema.Int64Attribute{
										Optional:            true,
										Description:         "Autonomous System used for iBGP peering session, when protocol is set to IBGP providing an autonomousSystem is required.",
										MarkdownDescription: "Autonomous System used for iBGP peering session, when protocol is set to IBGP providing an autonomousSystem is required.",
									},
									"cluster_id": schema.StringAttribute{
										Optional:            true,
										Description:         "Sets the cluster ID used by DefaultRouteReflectors, when protocol is set to IBGP providing a clusterID is required.",
										MarkdownDescription: "Sets the cluster ID used by DefaultRouteReflectors, when protocol is set to IBGP providing a clusterID is required.",
									},
									"export_policy": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
										MarkdownDescription: "Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
									},
									"import_policy": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
										MarkdownDescription: "Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
									},
									"keychain": schema.StringAttribute{
										Optional:            true,
										Description:         "Keychain to be used for authentication when overlay protocol is IBGP, ignored otherwise",
										MarkdownDescription: "Keychain to be used for authentication when overlay protocol is IBGP, ignored otherwise",
									},
									"rr_client_node_selector": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Label selector used to select Toponodes to configure as DefaultRouteReflectorClients, these are typically Leaf or Borderleaf nodes.  Used on conjunction with rrNodeSelector in order to configure the DefaultBGPPeers for both the DefaultRouteReflectors and DefaultRouteReflectorClients.",
										MarkdownDescription: "Label selector used to select Toponodes to configure as DefaultRouteReflectorClients, these are typically Leaf or Borderleaf nodes.  Used on conjunction with rrNodeSelector in order to configure the DefaultBGPPeers for both the DefaultRouteReflectors and DefaultRouteReflectorClients.",
									},
									"rr_ip_addresses": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of route reflector IP addresses not provisioned by this instance of a Fabric resource.  Used with rrClientNodeSelector to configure the DefaultBGPPeers on the selected nodes to peer the list of external route reflector IPs.",
										MarkdownDescription: "List of route reflector IP addresses not provisioned by this instance of a Fabric resource.  Used with rrClientNodeSelector to configure the DefaultBGPPeers on the selected nodes to peer the list of external route reflector IPs.",
									},
									"rr_node_selector": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Label selector used to select Toponodes to configure as DefaultRouteReflectors, these are typically Spine, Superspine or Borderleaf nodes. Used on conjunction with rrClientNodeSelector in order to configure the DefaultBGPPeers for both the DefaultRouteReflectors and DefaultRouteReflectorClients.",
										MarkdownDescription: "Label selector used to select Toponodes to configure as DefaultRouteReflectors, these are typically Spine, Superspine or Borderleaf nodes. Used on conjunction with rrClientNodeSelector in order to configure the DefaultBGPPeers for both the DefaultRouteReflectors and DefaultRouteReflectorClients.",
									},
									"timers": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"connect_retry": schema.Int64Attribute{
												Optional:            true,
												Description:         "The time interval in seconds between successive attempts to establish a session with a peer.",
												MarkdownDescription: "The time interval in seconds between successive attempts to establish a session with a peer.",
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
											"hold_time": schema.Int64Attribute{
												Optional:            true,
												Description:         "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
												MarkdownDescription: "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
												Validators: []validator.Int64{
													int64validator.Between(0, 65535),
												},
											},
											"keep_alive": schema.Int64Attribute{
												Optional:            true,
												Description:         "The interval in seconds between successive keepalive messages sent to the peer.",
												MarkdownDescription: "The interval in seconds between successive keepalive messages sent to the peer.",
												Validators: []validator.Int64{
													int64validator.Between(0, 21845),
												},
											},
											"minimum_advertisement_interval": schema.Int64Attribute{
												Optional:            true,
												Description:         "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
												MarkdownDescription: "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
												Validators: []validator.Int64{
													int64validator.Between(1, 255),
												},
											},
										},
										CustomType: TimersType{
											ObjectType: types.ObjectType{
												AttrTypes: TimersValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "Timer configurations",
										MarkdownDescription: "Timer configurations",
									},
								},
								CustomType: BgpType{
									ObjectType: types.ObjectType{
										AttrTypes: BgpValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Overlay specific BGP properties.",
								MarkdownDescription: "Overlay specific BGP properties.",
							},
							"protocol": schema.StringAttribute{
								Required:            true,
								Description:         "List of routing protocols to used to advertise EVPN routes for overlay services.  When EBGP is used, the BGP properties configured under the spec.underlayProtocol will be used.",
								MarkdownDescription: "List of routing protocols to used to advertise EVPN routes for overlay services.  When EBGP is used, the BGP properties configured under the spec.underlayProtocol will be used.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"IBGP",
										"EBGP",
									),
								},
							},
						},
						CustomType: OverlayProtocolType{
							ObjectType: types.ObjectType{
								AttrTypes: OverlayProtocolValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Set the overlay protocol used",
						MarkdownDescription: "Set the overlay protocol used",
					},
					"route_leaking": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"export_policy": schema.StringAttribute{
								Required:            true,
								Description:         "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
								MarkdownDescription: "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
							},
							"import_policy": schema.StringAttribute{
								Required:            true,
								Description:         "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
								MarkdownDescription: "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
							},
						},
						CustomType: RouteLeaking2Type{
							ObjectType: types.ObjectType{
								AttrTypes: RouteLeaking2Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
						MarkdownDescription: "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
					},
					"spines": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"asn_pool": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
								MarkdownDescription: "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
							},
							"route_leaking": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"export_policy": schema.StringAttribute{
										Required:            true,
										Description:         "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
										MarkdownDescription: "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
									},
									"import_policy": schema.StringAttribute{
										Required:            true,
										Description:         "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
										MarkdownDescription: "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
									},
								},
								CustomType: RouteLeaking3Type{
									ObjectType: types.ObjectType{
										AttrTypes: RouteLeaking3Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
								MarkdownDescription: "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
							},
							"spine_node_selector": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Label selector used to select Toponodes to configure as Spine nodes.",
								MarkdownDescription: "Label selector used to select Toponodes to configure as Spine nodes.",
							},
							"system_pool_ipv4": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
							},
							"system_pool_ipv6": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
							},
						},
						CustomType: SpinesType{
							ObjectType: types.ObjectType{
								AttrTypes: SpinesValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"super_spines": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"asn_pool": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
								MarkdownDescription: "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. This reference will take precedence over the spec.underlayProtocol.asnPool.",
							},
							"route_leaking": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"export_policy": schema.StringAttribute{
										Required:            true,
										Description:         "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
										MarkdownDescription: "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
									},
									"import_policy": schema.StringAttribute{
										Required:            true,
										Description:         "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
										MarkdownDescription: "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
									},
								},
								CustomType: RouteLeaking4Type{
									ObjectType: types.ObjectType{
										AttrTypes: RouteLeaking4Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
								MarkdownDescription: "Route leaking controlled by routing policies in and out of the DefaultRouters on each node.  If specified under the Leafs, Spines, SuperSpines, or BorderLeafs those will take precedence.",
							},
							"super_spine_node_selector": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Label selector used to select Toponodes to configure as Superspine nodes.",
								MarkdownDescription: "Label selector used to select Toponodes to configure as Superspine nodes.",
							},
							"system_pool_ipv4": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV4.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
							},
							"system_pool_ipv6": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
								MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  This reference will take precedence over the spec.systemPoolIPV6.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
							},
						},
						CustomType: SuperSpinesType{
							ObjectType: types.ObjectType{
								AttrTypes: SuperSpinesValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"system_pool_ipv4": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
						MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
					},
					"system_pool_ipv6": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
						MarkdownDescription: "Reference to an IPAllocationPool used to dynamically allocate an IPv6 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.  Both IPv4 and IPv6 pools can be configured simultaneously for dual-stack system/lo0 interfaces.",
					},
					"underlay_protocol": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"bfd": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"desired_min_transmit_int": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The minimum interval in microseconds between transmission of BFD control packets.",
										MarkdownDescription: "The minimum interval in microseconds between transmission of BFD control packets.",
										Validators: []validator.Int64{
											int64validator.Between(10000, 100000000),
										},
										Default: int64default.StaticInt64(1000000),
									},
									"detection_multiplier": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The number of packets that must be missed to declare this session as down.",
										MarkdownDescription: "The number of packets that must be missed to declare this session as down.",
										Validators: []validator.Int64{
											int64validator.Between(3, 20),
										},
										Default: int64default.StaticInt64(3),
									},
									"enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable Biforward Detection.",
										MarkdownDescription: "Enable Biforward Detection.",
										Default:             booldefault.StaticBool(false),
									},
									"min_echo_receive_interval": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The minimum interval between echo packets the local node can receive in microseconds.",
										MarkdownDescription: "The minimum interval between echo packets the local node can receive in microseconds.",
										Validators: []validator.Int64{
											int64validator.Between(0, 100000000),
										},
										Default: int64default.StaticInt64(1000000),
									},
									"required_min_receive": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The minimum interval in microseconds between received BFD control packets that this system should support.",
										MarkdownDescription: "The minimum interval in microseconds between received BFD control packets that this system should support.",
										Validators: []validator.Int64{
											int64validator.Between(10000, 100000000),
										},
										Default: int64default.StaticInt64(1000000),
									},
									"ttl": schema.Int64Attribute{
										Optional:            true,
										Description:         "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
										MarkdownDescription: "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
										Validators: []validator.Int64{
											int64validator.Between(2, 255),
										},
									},
								},
								CustomType: Bfd1Type{
									ObjectType: types.ObjectType{
										AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Enable BFD on underlay protocol",
								MarkdownDescription: "Enable BFD on underlay protocol",
							},
							"bgp": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"asn_pool": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.",
										MarkdownDescription: "Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol. If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.",
									},
									"export_policy": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
										MarkdownDescription: "Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
									},
									"import_policy": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
										MarkdownDescription: "Reference to a Policy, when left empty or not specified the Fabric will automatically generate a policy for the specified protocols.",
									},
									"keychain": schema.StringAttribute{
										Optional:            true,
										Description:         "Keychain to be used for authentication",
										MarkdownDescription: "Keychain to be used for authentication",
									},
									"timers": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"connect_retry": schema.Int64Attribute{
												Optional:            true,
												Description:         "The time interval in seconds between successive attempts to establish a session with a peer.",
												MarkdownDescription: "The time interval in seconds between successive attempts to establish a session with a peer.",
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
											"hold_time": schema.Int64Attribute{
												Optional:            true,
												Description:         "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
												MarkdownDescription: "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
												Validators: []validator.Int64{
													int64validator.Between(0, 65535),
												},
											},
											"keep_alive": schema.Int64Attribute{
												Optional:            true,
												Description:         "The interval in seconds between successive keepalive messages sent to the peer.",
												MarkdownDescription: "The interval in seconds between successive keepalive messages sent to the peer.",
												Validators: []validator.Int64{
													int64validator.Between(0, 21845),
												},
											},
											"minimum_advertisement_interval": schema.Int64Attribute{
												Optional:            true,
												Description:         "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
												MarkdownDescription: "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
												Validators: []validator.Int64{
													int64validator.Between(1, 255),
												},
											},
										},
										CustomType: Timers1Type{
											ObjectType: types.ObjectType{
												AttrTypes: Timers1Value{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "Timer configurations",
										MarkdownDescription: "Timer configurations",
									},
								},
								CustomType: Bgp1Type{
									ObjectType: types.ObjectType{
										AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Underlay specific BGP properties.",
								MarkdownDescription: "Underlay specific BGP properties.",
							},
							"ospf": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"address_family": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Selects enabled address families for OSPFv3. If not specified, both address families will be enabled by default when OSPFv3 underlay is configured.",
										MarkdownDescription: "Selects enabled address families for OSPFv3. If not specified, both address families will be enabled by default when OSPFv3 underlay is configured.",
									},
								},
								CustomType: OspfType{
									ObjectType: types.ObjectType{
										AttrTypes: OspfValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "OSPF underlay properties.",
								MarkdownDescription: "OSPF underlay properties.",
							},
							"protocol": schema.ListAttribute{
								ElementType:         types.StringType,
								Required:            true,
								Description:         "List of routing protocols to used between peers of an ISL.  Multiple protocols may be listed, if so multiple protocols will be used.",
								MarkdownDescription: "List of routing protocols to used between peers of an ISL.  Multiple protocols may be listed, if so multiple protocols will be used.",
							},
						},
						CustomType: UnderlayProtocolType{
							ObjectType: types.ObjectType{
								AttrTypes: UnderlayProtocolValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Set the underlay protocol used",
						MarkdownDescription: "Set the underlay protocol used",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "The Fabric defines the desired state of a Fabric resource, enabling the automation and management of data center network fabrics. It includes configurations for IP address allocation pools, network topology roles (Leafs, Spines, SuperSpines, BorderLeafs), inter-switch links, and network protocols (underlay and overlay). The specification allows for detailed control over routing strategies, including ASN allocations for BGP-based protocols, and supports advanced features like BFD.",
				MarkdownDescription: "The Fabric defines the desired state of a Fabric resource, enabling the automation and management of data center network fabrics. It includes configurations for IP address allocation pools, network topology roles (Leafs, Spines, SuperSpines, BorderLeafs), inter-switch links, and network protocols (underlay and overlay). The specification allows for detailed control over routing strategies, including ASN allocations for BGP-based protocols, and supports advanced features like BFD.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"border_leaf_nodes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"node": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Name of the TopoNode.",
									MarkdownDescription: "Name of the TopoNode.",
								},
								"operating_system": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Operating system running on the node.",
									MarkdownDescription: "Operating system running on the node.",
								},
								"operating_system_version": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Operating system version running on the node.",
									MarkdownDescription: "Operating system version running on the node.",
								},
								"underlay_autonomous_system": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
									MarkdownDescription: "Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
								},
							},
							CustomType: BorderLeafNodesType{
								ObjectType: types.ObjectType{
									AttrTypes: BorderLeafNodesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "List of border leaf nodes in the Fabric.",
						MarkdownDescription: "List of border leaf nodes in the Fabric.",
					},
					"health": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates the health score of the Fabric.  The health score of the Fabric is determined by the aggregate health score of the resources emitted by the Fabric such as ISL, DefaultRouteReflectors etc.",
						MarkdownDescription: "Indicates the health score of the Fabric.  The health score of the Fabric is determined by the aggregate health score of the resources emitted by the Fabric such as ISL, DefaultRouteReflectors etc.",
					},
					"health_score_reason": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates the reason for the health score.",
						MarkdownDescription: "Indicates the reason for the health score.",
					},
					"last_change": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The time when the state of the resource last changed.",
						MarkdownDescription: "The time when the state of the resource last changed.",
					},
					"leaf_nodes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"node": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Name of the TopoNode.",
									MarkdownDescription: "Name of the TopoNode.",
								},
								"operating_system": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Operating system running on the node.",
									MarkdownDescription: "Operating system running on the node.",
								},
								"operating_system_version": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Operating system version running on the node.",
									MarkdownDescription: "Operating system version running on the node.",
								},
								"underlay_autonomous_system": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
									MarkdownDescription: "Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
								},
							},
							CustomType: LeafNodesType{
								ObjectType: types.ObjectType{
									AttrTypes: LeafNodesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "List of leaf nodes in the Fabric.",
						MarkdownDescription: "List of leaf nodes in the Fabric.",
					},
					"operational_state": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Operational state of the Fabric.  The operational state of the fabric is determined by monitoring the operational state of the following resources (if applicable): DefaultRouters, ISLs.",
						MarkdownDescription: "Operational state of the Fabric.  The operational state of the fabric is determined by monitoring the operational state of the following resources (if applicable): DefaultRouters, ISLs.",
					},
					"spine_nodes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"node": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Name of the TopoNode.",
									MarkdownDescription: "Name of the TopoNode.",
								},
								"operating_system": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Operating system running on the node.",
									MarkdownDescription: "Operating system running on the node.",
								},
								"operating_system_version": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Operating system version running on the node.",
									MarkdownDescription: "Operating system version running on the node.",
								},
								"underlay_autonomous_system": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
									MarkdownDescription: "Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
								},
							},
							CustomType: SpineNodesType{
								ObjectType: types.ObjectType{
									AttrTypes: SpineNodesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "List of spine nodes in the Fabric.",
						MarkdownDescription: "List of spine nodes in the Fabric.",
					},
					"super_spine_nodes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"node": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Name of the TopoNode.",
									MarkdownDescription: "Name of the TopoNode.",
								},
								"operating_system": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Operating system running on the node.",
									MarkdownDescription: "Operating system running on the node.",
								},
								"operating_system_version": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Operating system version running on the node.",
									MarkdownDescription: "Operating system version running on the node.",
								},
								"underlay_autonomous_system": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
									MarkdownDescription: "Underlay Autonomous System used for eBGP peering session, when protocol is set to eBGP this is required.",
								},
							},
							CustomType: SuperSpineNodesType{
								ObjectType: types.ObjectType{
									AttrTypes: SuperSpineNodesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "List of super spine nodes in the Fabric.",
						MarkdownDescription: "List of super spine nodes in the Fabric.",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "FabricStatus defines the observed state of Fabric",
				MarkdownDescription: "FabricStatus defines the observed state of Fabric",
			},
		},
	}
}

type FabricModel struct {
	Alarms     AlarmsValue     `tfsdk:"alarms"`
	ApiVersion types.String    `tfsdk:"api_version"`
	Deviations DeviationsValue `tfsdk:"deviations"`
	Kind       types.String    `tfsdk:"kind"`
	Metadata   MetadataValue   `tfsdk:"metadata"`
	Name       types.String    `tfsdk:"name"`
	Namespace  types.String    `tfsdk:"namespace"`
	Spec       SpecValue       `tfsdk:"spec"`
	Status     StatusValue     `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	borderLeafsAttribute, ok := attributes["border_leafs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`border_leafs is missing from object`)

		return nil, diags
	}

	borderLeafsVal, ok := borderLeafsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`border_leafs expected to be basetypes.ObjectValue, was: %T`, borderLeafsAttribute))
	}

	fabricSelectorAttribute, ok := attributes["fabric_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fabric_selector is missing from object`)

		return nil, diags
	}

	fabricSelectorVal, ok := fabricSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fabric_selector expected to be basetypes.ListValue, was: %T`, fabricSelectorAttribute))
	}

	interSwitchLinksAttribute, ok := attributes["inter_switch_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_links is missing from object`)

		return nil, diags
	}

	interSwitchLinksVal, ok := interSwitchLinksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_links expected to be basetypes.ObjectValue, was: %T`, interSwitchLinksAttribute))
	}

	leafsAttribute, ok := attributes["leafs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leafs is missing from object`)

		return nil, diags
	}

	leafsVal, ok := leafsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leafs expected to be basetypes.ObjectValue, was: %T`, leafsAttribute))
	}

	overlayProtocolAttribute, ok := attributes["overlay_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overlay_protocol is missing from object`)

		return nil, diags
	}

	overlayProtocolVal, ok := overlayProtocolAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overlay_protocol expected to be basetypes.ObjectValue, was: %T`, overlayProtocolAttribute))
	}

	routeLeaking2Attribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking_2 is missing from object`)

		return nil, diags
	}

	routeLeaking2Val, ok := routeLeaking2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking_2 expected to be basetypes.ObjectValue, was: %T`, routeLeaking2Attribute))
	}

	spinesAttribute, ok := attributes["spines"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spines is missing from object`)

		return nil, diags
	}

	spinesVal, ok := spinesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spines expected to be basetypes.ObjectValue, was: %T`, spinesAttribute))
	}

	superSpinesAttribute, ok := attributes["super_spines"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`super_spines is missing from object`)

		return nil, diags
	}

	superSpinesVal, ok := superSpinesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`super_spines expected to be basetypes.ObjectValue, was: %T`, superSpinesAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return nil, diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return nil, diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	underlayProtocolAttribute, ok := attributes["underlay_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_protocol is missing from object`)

		return nil, diags
	}

	underlayProtocolVal, ok := underlayProtocolAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_protocol expected to be basetypes.ObjectValue, was: %T`, underlayProtocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		BorderLeafs:      borderLeafsVal,
		FabricSelector:   fabricSelectorVal,
		InterSwitchLinks: interSwitchLinksVal,
		Leafs:            leafsVal,
		OverlayProtocol:  overlayProtocolVal,
		RouteLeaking2:    routeLeaking2Val,
		Spines:           spinesVal,
		SuperSpines:      superSpinesVal,
		SystemPoolIpv4:   systemPoolIpv4Val,
		SystemPoolIpv6:   systemPoolIpv6Val,
		UnderlayProtocol: underlayProtocolVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	borderLeafsAttribute, ok := attributes["border_leafs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`border_leafs is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	borderLeafsVal, ok := borderLeafsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`border_leafs expected to be basetypes.ObjectValue, was: %T`, borderLeafsAttribute))
	}

	fabricSelectorAttribute, ok := attributes["fabric_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fabric_selector is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	fabricSelectorVal, ok := fabricSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fabric_selector expected to be basetypes.ListValue, was: %T`, fabricSelectorAttribute))
	}

	interSwitchLinksAttribute, ok := attributes["inter_switch_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_links is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	interSwitchLinksVal, ok := interSwitchLinksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_links expected to be basetypes.ObjectValue, was: %T`, interSwitchLinksAttribute))
	}

	leafsAttribute, ok := attributes["leafs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leafs is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	leafsVal, ok := leafsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leafs expected to be basetypes.ObjectValue, was: %T`, leafsAttribute))
	}

	overlayProtocolAttribute, ok := attributes["overlay_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overlay_protocol is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	overlayProtocolVal, ok := overlayProtocolAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overlay_protocol expected to be basetypes.ObjectValue, was: %T`, overlayProtocolAttribute))
	}

	routeLeaking2Attribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking_2 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	routeLeaking2Val, ok := routeLeaking2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking_2 expected to be basetypes.ObjectValue, was: %T`, routeLeaking2Attribute))
	}

	spinesAttribute, ok := attributes["spines"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spines is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	spinesVal, ok := spinesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spines expected to be basetypes.ObjectValue, was: %T`, spinesAttribute))
	}

	superSpinesAttribute, ok := attributes["super_spines"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`super_spines is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	superSpinesVal, ok := superSpinesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`super_spines expected to be basetypes.ObjectValue, was: %T`, superSpinesAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	underlayProtocolAttribute, ok := attributes["underlay_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_protocol is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	underlayProtocolVal, ok := underlayProtocolAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_protocol expected to be basetypes.ObjectValue, was: %T`, underlayProtocolAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		BorderLeafs:      borderLeafsVal,
		FabricSelector:   fabricSelectorVal,
		InterSwitchLinks: interSwitchLinksVal,
		Leafs:            leafsVal,
		OverlayProtocol:  overlayProtocolVal,
		RouteLeaking2:    routeLeaking2Val,
		Spines:           spinesVal,
		SuperSpines:      superSpinesVal,
		SystemPoolIpv4:   systemPoolIpv4Val,
		SystemPoolIpv6:   systemPoolIpv6Val,
		UnderlayProtocol: underlayProtocolVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	BorderLeafs      basetypes.ObjectValue `tfsdk:"border_leafs"`
	FabricSelector   basetypes.ListValue   `tfsdk:"fabric_selector"`
	InterSwitchLinks basetypes.ObjectValue `tfsdk:"inter_switch_links"`
	Leafs            basetypes.ObjectValue `tfsdk:"leafs"`
	OverlayProtocol  basetypes.ObjectValue `tfsdk:"overlay_protocol"`
	RouteLeaking2    basetypes.ObjectValue `tfsdk:"route_leaking"`
	Spines           basetypes.ObjectValue `tfsdk:"spines"`
	SuperSpines      basetypes.ObjectValue `tfsdk:"super_spines"`
	SystemPoolIpv4   basetypes.StringValue `tfsdk:"system_pool_ipv4"`
	SystemPoolIpv6   basetypes.StringValue `tfsdk:"system_pool_ipv6"`
	UnderlayProtocol basetypes.ObjectValue `tfsdk:"underlay_protocol"`
	state            attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["border_leafs"] = basetypes.ObjectType{
		AttrTypes: BorderLeafsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["fabric_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["inter_switch_links"] = basetypes.ObjectType{
		AttrTypes: InterSwitchLinksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["leafs"] = basetypes.ObjectType{
		AttrTypes: LeafsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["overlay_protocol"] = basetypes.ObjectType{
		AttrTypes: OverlayProtocolValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["route_leaking"] = basetypes.ObjectType{
		AttrTypes: RouteLeaking2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spines"] = basetypes.ObjectType{
		AttrTypes: SpinesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["super_spines"] = basetypes.ObjectType{
		AttrTypes: SuperSpinesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["system_pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_pool_ipv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["underlay_protocol"] = basetypes.ObjectType{
		AttrTypes: UnderlayProtocolValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.BorderLeafs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["border_leafs"] = val

		val, err = v.FabricSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fabric_selector"] = val

		val, err = v.InterSwitchLinks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inter_switch_links"] = val

		val, err = v.Leafs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["leafs"] = val

		val, err = v.OverlayProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overlay_protocol"] = val

		val, err = v.RouteLeaking2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_leaking"] = val

		val, err = v.Spines.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spines"] = val

		val, err = v.SuperSpines.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["super_spines"] = val

		val, err = v.SystemPoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv4"] = val

		val, err = v.SystemPoolIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv6"] = val

		val, err = v.UnderlayProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["underlay_protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var borderLeafs basetypes.ObjectValue

	if v.BorderLeafs.IsNull() {
		borderLeafs = types.ObjectNull(
			BorderLeafsValue{}.AttributeTypes(ctx),
		)
	}

	if v.BorderLeafs.IsUnknown() {
		borderLeafs = types.ObjectUnknown(
			BorderLeafsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BorderLeafs.IsNull() && !v.BorderLeafs.IsUnknown() {
		borderLeafs = types.ObjectValueMust(
			BorderLeafsValue{}.AttributeTypes(ctx),
			v.BorderLeafs.Attributes(),
		)
	}

	var interSwitchLinks basetypes.ObjectValue

	if v.InterSwitchLinks.IsNull() {
		interSwitchLinks = types.ObjectNull(
			InterSwitchLinksValue{}.AttributeTypes(ctx),
		)
	}

	if v.InterSwitchLinks.IsUnknown() {
		interSwitchLinks = types.ObjectUnknown(
			InterSwitchLinksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InterSwitchLinks.IsNull() && !v.InterSwitchLinks.IsUnknown() {
		interSwitchLinks = types.ObjectValueMust(
			InterSwitchLinksValue{}.AttributeTypes(ctx),
			v.InterSwitchLinks.Attributes(),
		)
	}

	var leafs basetypes.ObjectValue

	if v.Leafs.IsNull() {
		leafs = types.ObjectNull(
			LeafsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Leafs.IsUnknown() {
		leafs = types.ObjectUnknown(
			LeafsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Leafs.IsNull() && !v.Leafs.IsUnknown() {
		leafs = types.ObjectValueMust(
			LeafsValue{}.AttributeTypes(ctx),
			v.Leafs.Attributes(),
		)
	}

	var overlayProtocol basetypes.ObjectValue

	if v.OverlayProtocol.IsNull() {
		overlayProtocol = types.ObjectNull(
			OverlayProtocolValue{}.AttributeTypes(ctx),
		)
	}

	if v.OverlayProtocol.IsUnknown() {
		overlayProtocol = types.ObjectUnknown(
			OverlayProtocolValue{}.AttributeTypes(ctx),
		)
	}

	if !v.OverlayProtocol.IsNull() && !v.OverlayProtocol.IsUnknown() {
		overlayProtocol = types.ObjectValueMust(
			OverlayProtocolValue{}.AttributeTypes(ctx),
			v.OverlayProtocol.Attributes(),
		)
	}

	var routeLeaking2 basetypes.ObjectValue

	if v.RouteLeaking2.IsNull() {
		routeLeaking2 = types.ObjectNull(
			RouteLeaking2Value{}.AttributeTypes(ctx),
		)
	}

	if v.RouteLeaking2.IsUnknown() {
		routeLeaking2 = types.ObjectUnknown(
			RouteLeaking2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteLeaking2.IsNull() && !v.RouteLeaking2.IsUnknown() {
		routeLeaking2 = types.ObjectValueMust(
			RouteLeaking2Value{}.AttributeTypes(ctx),
			v.RouteLeaking2.Attributes(),
		)
	}

	var spines basetypes.ObjectValue

	if v.Spines.IsNull() {
		spines = types.ObjectNull(
			SpinesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spines.IsUnknown() {
		spines = types.ObjectUnknown(
			SpinesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spines.IsNull() && !v.Spines.IsUnknown() {
		spines = types.ObjectValueMust(
			SpinesValue{}.AttributeTypes(ctx),
			v.Spines.Attributes(),
		)
	}

	var superSpines basetypes.ObjectValue

	if v.SuperSpines.IsNull() {
		superSpines = types.ObjectNull(
			SuperSpinesValue{}.AttributeTypes(ctx),
		)
	}

	if v.SuperSpines.IsUnknown() {
		superSpines = types.ObjectUnknown(
			SuperSpinesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SuperSpines.IsNull() && !v.SuperSpines.IsUnknown() {
		superSpines = types.ObjectValueMust(
			SuperSpinesValue{}.AttributeTypes(ctx),
			v.SuperSpines.Attributes(),
		)
	}

	var underlayProtocol basetypes.ObjectValue

	if v.UnderlayProtocol.IsNull() {
		underlayProtocol = types.ObjectNull(
			UnderlayProtocolValue{}.AttributeTypes(ctx),
		)
	}

	if v.UnderlayProtocol.IsUnknown() {
		underlayProtocol = types.ObjectUnknown(
			UnderlayProtocolValue{}.AttributeTypes(ctx),
		)
	}

	if !v.UnderlayProtocol.IsNull() && !v.UnderlayProtocol.IsUnknown() {
		underlayProtocol = types.ObjectValueMust(
			UnderlayProtocolValue{}.AttributeTypes(ctx),
			v.UnderlayProtocol.Attributes(),
		)
	}

	var fabricSelectorVal basetypes.ListValue
	switch {
	case v.FabricSelector.IsUnknown():
		fabricSelectorVal = types.ListUnknown(types.StringType)
	case v.FabricSelector.IsNull():
		fabricSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		fabricSelectorVal, d = types.ListValue(types.StringType, v.FabricSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"border_leafs": basetypes.ObjectType{
				AttrTypes: BorderLeafsValue{}.AttributeTypes(ctx),
			},
			"fabric_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"inter_switch_links": basetypes.ObjectType{
				AttrTypes: InterSwitchLinksValue{}.AttributeTypes(ctx),
			},
			"leafs": basetypes.ObjectType{
				AttrTypes: LeafsValue{}.AttributeTypes(ctx),
			},
			"overlay_protocol": basetypes.ObjectType{
				AttrTypes: OverlayProtocolValue{}.AttributeTypes(ctx),
			},
			"route_leaking": basetypes.ObjectType{
				AttrTypes: RouteLeaking2Value{}.AttributeTypes(ctx),
			},
			"spines": basetypes.ObjectType{
				AttrTypes: SpinesValue{}.AttributeTypes(ctx),
			},
			"super_spines": basetypes.ObjectType{
				AttrTypes: SuperSpinesValue{}.AttributeTypes(ctx),
			},
			"system_pool_ipv4": basetypes.StringType{},
			"system_pool_ipv6": basetypes.StringType{},
			"underlay_protocol": basetypes.ObjectType{
				AttrTypes: UnderlayProtocolValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"border_leafs": basetypes.ObjectType{
			AttrTypes: BorderLeafsValue{}.AttributeTypes(ctx),
		},
		"fabric_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"inter_switch_links": basetypes.ObjectType{
			AttrTypes: InterSwitchLinksValue{}.AttributeTypes(ctx),
		},
		"leafs": basetypes.ObjectType{
			AttrTypes: LeafsValue{}.AttributeTypes(ctx),
		},
		"overlay_protocol": basetypes.ObjectType{
			AttrTypes: OverlayProtocolValue{}.AttributeTypes(ctx),
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeaking2Value{}.AttributeTypes(ctx),
		},
		"spines": basetypes.ObjectType{
			AttrTypes: SpinesValue{}.AttributeTypes(ctx),
		},
		"super_spines": basetypes.ObjectType{
			AttrTypes: SuperSpinesValue{}.AttributeTypes(ctx),
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
		"underlay_protocol": basetypes.ObjectType{
			AttrTypes: UnderlayProtocolValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"border_leafs":       borderLeafs,
			"fabric_selector":    fabricSelectorVal,
			"inter_switch_links": interSwitchLinks,
			"leafs":              leafs,
			"overlay_protocol":   overlayProtocol,
			"route_leaking":      routeLeaking2,
			"spines":             spines,
			"super_spines":       superSpines,
			"system_pool_ipv4":   v.SystemPoolIpv4,
			"system_pool_ipv6":   v.SystemPoolIpv6,
			"underlay_protocol":  underlayProtocol,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BorderLeafs.Equal(other.BorderLeafs) {
		return false
	}

	if !v.FabricSelector.Equal(other.FabricSelector) {
		return false
	}

	if !v.InterSwitchLinks.Equal(other.InterSwitchLinks) {
		return false
	}

	if !v.Leafs.Equal(other.Leafs) {
		return false
	}

	if !v.OverlayProtocol.Equal(other.OverlayProtocol) {
		return false
	}

	if !v.RouteLeaking2.Equal(other.RouteLeaking2) {
		return false
	}

	if !v.Spines.Equal(other.Spines) {
		return false
	}

	if !v.SuperSpines.Equal(other.SuperSpines) {
		return false
	}

	if !v.SystemPoolIpv4.Equal(other.SystemPoolIpv4) {
		return false
	}

	if !v.SystemPoolIpv6.Equal(other.SystemPoolIpv6) {
		return false
	}

	if !v.UnderlayProtocol.Equal(other.UnderlayProtocol) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"border_leafs": basetypes.ObjectType{
			AttrTypes: BorderLeafsValue{}.AttributeTypes(ctx),
		},
		"fabric_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"inter_switch_links": basetypes.ObjectType{
			AttrTypes: InterSwitchLinksValue{}.AttributeTypes(ctx),
		},
		"leafs": basetypes.ObjectType{
			AttrTypes: LeafsValue{}.AttributeTypes(ctx),
		},
		"overlay_protocol": basetypes.ObjectType{
			AttrTypes: OverlayProtocolValue{}.AttributeTypes(ctx),
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeaking2Value{}.AttributeTypes(ctx),
		},
		"spines": basetypes.ObjectType{
			AttrTypes: SpinesValue{}.AttributeTypes(ctx),
		},
		"super_spines": basetypes.ObjectType{
			AttrTypes: SuperSpinesValue{}.AttributeTypes(ctx),
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
		"underlay_protocol": basetypes.ObjectType{
			AttrTypes: UnderlayProtocolValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BorderLeafsType{}

type BorderLeafsType struct {
	basetypes.ObjectType
}

func (t BorderLeafsType) Equal(o attr.Type) bool {
	other, ok := o.(BorderLeafsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BorderLeafsType) String() string {
	return "BorderLeafsType"
}

func (t BorderLeafsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return nil, diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	borderLeafNodeSelectorAttribute, ok := attributes["border_leaf_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`border_leaf_node_selector is missing from object`)

		return nil, diags
	}

	borderLeafNodeSelectorVal, ok := borderLeafNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`border_leaf_node_selector expected to be basetypes.ListValue, was: %T`, borderLeafNodeSelectorAttribute))
	}

	routeLeakingAttribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking is missing from object`)

		return nil, diags
	}

	routeLeakingVal, ok := routeLeakingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking expected to be basetypes.ObjectValue, was: %T`, routeLeakingAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return nil, diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return nil, diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BorderLeafsValue{
		AsnPool:                asnPoolVal,
		BorderLeafNodeSelector: borderLeafNodeSelectorVal,
		RouteLeaking:           routeLeakingVal,
		SystemPoolIpv4:         systemPoolIpv4Val,
		SystemPoolIpv6:         systemPoolIpv6Val,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBorderLeafsValueNull() BorderLeafsValue {
	return BorderLeafsValue{
		state: attr.ValueStateNull,
	}
}

func NewBorderLeafsValueUnknown() BorderLeafsValue {
	return BorderLeafsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBorderLeafsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BorderLeafsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BorderLeafsValue Attribute Value",
				"While creating a BorderLeafsValue value, a missing attribute value was detected. "+
					"A BorderLeafsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BorderLeafsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BorderLeafsValue Attribute Type",
				"While creating a BorderLeafsValue value, an invalid attribute value was detected. "+
					"A BorderLeafsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BorderLeafsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BorderLeafsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BorderLeafsValue Attribute Value",
				"While creating a BorderLeafsValue value, an extra attribute value was detected. "+
					"A BorderLeafsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BorderLeafsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBorderLeafsValueUnknown(), diags
	}

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return NewBorderLeafsValueUnknown(), diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	borderLeafNodeSelectorAttribute, ok := attributes["border_leaf_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`border_leaf_node_selector is missing from object`)

		return NewBorderLeafsValueUnknown(), diags
	}

	borderLeafNodeSelectorVal, ok := borderLeafNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`border_leaf_node_selector expected to be basetypes.ListValue, was: %T`, borderLeafNodeSelectorAttribute))
	}

	routeLeakingAttribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking is missing from object`)

		return NewBorderLeafsValueUnknown(), diags
	}

	routeLeakingVal, ok := routeLeakingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking expected to be basetypes.ObjectValue, was: %T`, routeLeakingAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return NewBorderLeafsValueUnknown(), diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return NewBorderLeafsValueUnknown(), diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	if diags.HasError() {
		return NewBorderLeafsValueUnknown(), diags
	}

	return BorderLeafsValue{
		AsnPool:                asnPoolVal,
		BorderLeafNodeSelector: borderLeafNodeSelectorVal,
		RouteLeaking:           routeLeakingVal,
		SystemPoolIpv4:         systemPoolIpv4Val,
		SystemPoolIpv6:         systemPoolIpv6Val,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBorderLeafsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BorderLeafsValue {
	object, diags := NewBorderLeafsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBorderLeafsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BorderLeafsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBorderLeafsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBorderLeafsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBorderLeafsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBorderLeafsValueMust(BorderLeafsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BorderLeafsType) ValueType(ctx context.Context) attr.Value {
	return BorderLeafsValue{}
}

var _ basetypes.ObjectValuable = BorderLeafsValue{}

type BorderLeafsValue struct {
	AsnPool                basetypes.StringValue `tfsdk:"asn_pool"`
	BorderLeafNodeSelector basetypes.ListValue   `tfsdk:"border_leaf_node_selector"`
	RouteLeaking           basetypes.ObjectValue `tfsdk:"route_leaking"`
	SystemPoolIpv4         basetypes.StringValue `tfsdk:"system_pool_ipv4"`
	SystemPoolIpv6         basetypes.StringValue `tfsdk:"system_pool_ipv6"`
	state                  attr.ValueState
}

func (v BorderLeafsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["border_leaf_node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["route_leaking"] = basetypes.ObjectType{
		AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["system_pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_pool_ipv6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AsnPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn_pool"] = val

		val, err = v.BorderLeafNodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["border_leaf_node_selector"] = val

		val, err = v.RouteLeaking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_leaking"] = val

		val, err = v.SystemPoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv4"] = val

		val, err = v.SystemPoolIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BorderLeafsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BorderLeafsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BorderLeafsValue) String() string {
	return "BorderLeafsValue"
}

func (v BorderLeafsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var routeLeaking basetypes.ObjectValue

	if v.RouteLeaking.IsNull() {
		routeLeaking = types.ObjectNull(
			RouteLeakingValue{}.AttributeTypes(ctx),
		)
	}

	if v.RouteLeaking.IsUnknown() {
		routeLeaking = types.ObjectUnknown(
			RouteLeakingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteLeaking.IsNull() && !v.RouteLeaking.IsUnknown() {
		routeLeaking = types.ObjectValueMust(
			RouteLeakingValue{}.AttributeTypes(ctx),
			v.RouteLeaking.Attributes(),
		)
	}

	var borderLeafNodeSelectorVal basetypes.ListValue
	switch {
	case v.BorderLeafNodeSelector.IsUnknown():
		borderLeafNodeSelectorVal = types.ListUnknown(types.StringType)
	case v.BorderLeafNodeSelector.IsNull():
		borderLeafNodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		borderLeafNodeSelectorVal, d = types.ListValue(types.StringType, v.BorderLeafNodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"border_leaf_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_leaking": basetypes.ObjectType{
				AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
			},
			"system_pool_ipv4": basetypes.StringType{},
			"system_pool_ipv6": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"border_leaf_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn_pool":                  v.AsnPool,
			"border_leaf_node_selector": borderLeafNodeSelectorVal,
			"route_leaking":             routeLeaking,
			"system_pool_ipv4":          v.SystemPoolIpv4,
			"system_pool_ipv6":          v.SystemPoolIpv6,
		})

	return objVal, diags
}

func (v BorderLeafsValue) Equal(o attr.Value) bool {
	other, ok := o.(BorderLeafsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsnPool.Equal(other.AsnPool) {
		return false
	}

	if !v.BorderLeafNodeSelector.Equal(other.BorderLeafNodeSelector) {
		return false
	}

	if !v.RouteLeaking.Equal(other.RouteLeaking) {
		return false
	}

	if !v.SystemPoolIpv4.Equal(other.SystemPoolIpv4) {
		return false
	}

	if !v.SystemPoolIpv6.Equal(other.SystemPoolIpv6) {
		return false
	}

	return true
}

func (v BorderLeafsValue) Type(ctx context.Context) attr.Type {
	return BorderLeafsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BorderLeafsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"border_leaf_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RouteLeakingType{}

type RouteLeakingType struct {
	basetypes.ObjectType
}

func (t RouteLeakingType) Equal(o attr.Type) bool {
	other, ok := o.(RouteLeakingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteLeakingType) String() string {
	return "RouteLeakingType"
}

func (t RouteLeakingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteLeakingValue{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeakingValueNull() RouteLeakingValue {
	return RouteLeakingValue{
		state: attr.ValueStateNull,
	}
}

func NewRouteLeakingValueUnknown() RouteLeakingValue {
	return RouteLeakingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteLeakingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteLeakingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteLeakingValue Attribute Value",
				"While creating a RouteLeakingValue value, a missing attribute value was detected. "+
					"A RouteLeakingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteLeakingValue Attribute Type",
				"While creating a RouteLeakingValue value, an invalid attribute value was detected. "+
					"A RouteLeakingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteLeakingValue Attribute Value",
				"While creating a RouteLeakingValue value, an extra attribute value was detected. "+
					"A RouteLeakingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteLeakingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteLeakingValueUnknown(), diags
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewRouteLeakingValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewRouteLeakingValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return NewRouteLeakingValueUnknown(), diags
	}

	return RouteLeakingValue{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeakingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteLeakingValue {
	object, diags := NewRouteLeakingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteLeakingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteLeakingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteLeakingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteLeakingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteLeakingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteLeakingValueMust(RouteLeakingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteLeakingType) ValueType(ctx context.Context) attr.Value {
	return RouteLeakingValue{}
}

var _ basetypes.ObjectValuable = RouteLeakingValue{}

type RouteLeakingValue struct {
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	state        attr.ValueState
}

func (v RouteLeakingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteLeakingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteLeakingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteLeakingValue) String() string {
	return "RouteLeakingValue"
}

func (v RouteLeakingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"export_policy": v.ExportPolicy,
			"import_policy": v.ImportPolicy,
		})

	return objVal, diags
}

func (v RouteLeakingValue) Equal(o attr.Value) bool {
	other, ok := o.(RouteLeakingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	return true
}

func (v RouteLeakingValue) Type(ctx context.Context) attr.Type {
	return RouteLeakingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteLeakingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterSwitchLinksType{}

type InterSwitchLinksType struct {
	basetypes.ObjectType
}

func (t InterSwitchLinksType) Equal(o attr.Type) bool {
	other, ok := o.(InterSwitchLinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterSwitchLinksType) String() string {
	return "InterSwitchLinksType"
}

func (t InterSwitchLinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	linkSelectorAttribute, ok := attributes["link_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_selector is missing from object`)

		return nil, diags
	}

	linkSelectorVal, ok := linkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_selector expected to be basetypes.ListValue, was: %T`, linkSelectorAttribute))
	}

	poolIpv4Attribute, ok := attributes["pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv4 is missing from object`)

		return nil, diags
	}

	poolIpv4Val, ok := poolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv4 expected to be basetypes.StringValue, was: %T`, poolIpv4Attribute))
	}

	poolIpv6Attribute, ok := attributes["pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv6 is missing from object`)

		return nil, diags
	}

	poolIpv6Val, ok := poolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv6 expected to be basetypes.StringValue, was: %T`, poolIpv6Attribute))
	}

	qosAttribute, ok := attributes["qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos is missing from object`)

		return nil, diags
	}

	qosVal, ok := qosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos expected to be basetypes.ObjectValue, was: %T`, qosAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return nil, diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterSwitchLinksValue{
		IpMtu:        ipMtuVal,
		LinkSelector: linkSelectorVal,
		PoolIpv4:     poolIpv4Val,
		PoolIpv6:     poolIpv6Val,
		Qos:          qosVal,
		Unnumbered:   unnumberedVal,
		VlanId:       vlanIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewInterSwitchLinksValueNull() InterSwitchLinksValue {
	return InterSwitchLinksValue{
		state: attr.ValueStateNull,
	}
}

func NewInterSwitchLinksValueUnknown() InterSwitchLinksValue {
	return InterSwitchLinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterSwitchLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterSwitchLinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterSwitchLinksValue Attribute Value",
				"While creating a InterSwitchLinksValue value, a missing attribute value was detected. "+
					"A InterSwitchLinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterSwitchLinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterSwitchLinksValue Attribute Type",
				"While creating a InterSwitchLinksValue value, an invalid attribute value was detected. "+
					"A InterSwitchLinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterSwitchLinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterSwitchLinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterSwitchLinksValue Attribute Value",
				"While creating a InterSwitchLinksValue value, an extra attribute value was detected. "+
					"A InterSwitchLinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterSwitchLinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterSwitchLinksValueUnknown(), diags
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewInterSwitchLinksValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	linkSelectorAttribute, ok := attributes["link_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_selector is missing from object`)

		return NewInterSwitchLinksValueUnknown(), diags
	}

	linkSelectorVal, ok := linkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_selector expected to be basetypes.ListValue, was: %T`, linkSelectorAttribute))
	}

	poolIpv4Attribute, ok := attributes["pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv4 is missing from object`)

		return NewInterSwitchLinksValueUnknown(), diags
	}

	poolIpv4Val, ok := poolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv4 expected to be basetypes.StringValue, was: %T`, poolIpv4Attribute))
	}

	poolIpv6Attribute, ok := attributes["pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv6 is missing from object`)

		return NewInterSwitchLinksValueUnknown(), diags
	}

	poolIpv6Val, ok := poolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv6 expected to be basetypes.StringValue, was: %T`, poolIpv6Attribute))
	}

	qosAttribute, ok := attributes["qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos is missing from object`)

		return NewInterSwitchLinksValueUnknown(), diags
	}

	qosVal, ok := qosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos expected to be basetypes.ObjectValue, was: %T`, qosAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return NewInterSwitchLinksValueUnknown(), diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewInterSwitchLinksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewInterSwitchLinksValueUnknown(), diags
	}

	return InterSwitchLinksValue{
		IpMtu:        ipMtuVal,
		LinkSelector: linkSelectorVal,
		PoolIpv4:     poolIpv4Val,
		PoolIpv6:     poolIpv6Val,
		Qos:          qosVal,
		Unnumbered:   unnumberedVal,
		VlanId:       vlanIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewInterSwitchLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterSwitchLinksValue {
	object, diags := NewInterSwitchLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterSwitchLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterSwitchLinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterSwitchLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterSwitchLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterSwitchLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterSwitchLinksValueMust(InterSwitchLinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterSwitchLinksType) ValueType(ctx context.Context) attr.Value {
	return InterSwitchLinksValue{}
}

var _ basetypes.ObjectValuable = InterSwitchLinksValue{}

type InterSwitchLinksValue struct {
	IpMtu        basetypes.Int64Value  `tfsdk:"ip_mtu"`
	LinkSelector basetypes.ListValue   `tfsdk:"link_selector"`
	PoolIpv4     basetypes.StringValue `tfsdk:"pool_ipv4"`
	PoolIpv6     basetypes.StringValue `tfsdk:"pool_ipv6"`
	Qos          basetypes.ObjectValue `tfsdk:"qos"`
	Unnumbered   basetypes.StringValue `tfsdk:"unnumbered"`
	VlanId       basetypes.Int64Value  `tfsdk:"vlan_id"`
	state        attr.ValueState
}

func (v InterSwitchLinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["link_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pool_ipv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["qos"] = basetypes.ObjectType{
		AttrTypes: QosValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["unnumbered"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.LinkSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_selector"] = val

		val, err = v.PoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pool_ipv4"] = val

		val, err = v.PoolIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pool_ipv6"] = val

		val, err = v.Qos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos"] = val

		val, err = v.Unnumbered.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unnumbered"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterSwitchLinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterSwitchLinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterSwitchLinksValue) String() string {
	return "InterSwitchLinksValue"
}

func (v InterSwitchLinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var qos basetypes.ObjectValue

	if v.Qos.IsNull() {
		qos = types.ObjectNull(
			QosValue{}.AttributeTypes(ctx),
		)
	}

	if v.Qos.IsUnknown() {
		qos = types.ObjectUnknown(
			QosValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Qos.IsNull() && !v.Qos.IsUnknown() {
		qos = types.ObjectValueMust(
			QosValue{}.AttributeTypes(ctx),
			v.Qos.Attributes(),
		)
	}

	var linkSelectorVal basetypes.ListValue
	switch {
	case v.LinkSelector.IsUnknown():
		linkSelectorVal = types.ListUnknown(types.StringType)
	case v.LinkSelector.IsNull():
		linkSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		linkSelectorVal, d = types.ListValue(types.StringType, v.LinkSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ip_mtu": basetypes.Int64Type{},
			"link_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"pool_ipv4": basetypes.StringType{},
			"pool_ipv6": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"unnumbered": basetypes.StringType{},
			"vlan_id":    basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ip_mtu": basetypes.Int64Type{},
		"link_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"pool_ipv4": basetypes.StringType{},
		"pool_ipv6": basetypes.StringType{},
		"qos": basetypes.ObjectType{
			AttrTypes: QosValue{}.AttributeTypes(ctx),
		},
		"unnumbered": basetypes.StringType{},
		"vlan_id":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_mtu":        v.IpMtu,
			"link_selector": linkSelectorVal,
			"pool_ipv4":     v.PoolIpv4,
			"pool_ipv6":     v.PoolIpv6,
			"qos":           qos,
			"unnumbered":    v.Unnumbered,
			"vlan_id":       v.VlanId,
		})

	return objVal, diags
}

func (v InterSwitchLinksValue) Equal(o attr.Value) bool {
	other, ok := o.(InterSwitchLinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.LinkSelector.Equal(other.LinkSelector) {
		return false
	}

	if !v.PoolIpv4.Equal(other.PoolIpv4) {
		return false
	}

	if !v.PoolIpv6.Equal(other.PoolIpv6) {
		return false
	}

	if !v.Qos.Equal(other.Qos) {
		return false
	}

	if !v.Unnumbered.Equal(other.Unnumbered) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v InterSwitchLinksValue) Type(ctx context.Context) attr.Type {
	return InterSwitchLinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterSwitchLinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_mtu": basetypes.Int64Type{},
		"link_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"pool_ipv4": basetypes.StringType{},
		"pool_ipv6": basetypes.StringType{},
		"qos": basetypes.ObjectType{
			AttrTypes: QosValue{}.AttributeTypes(ctx),
		},
		"unnumbered": basetypes.StringType{},
		"vlan_id":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = QosType{}

type QosType struct {
	basetypes.ObjectType
}

func (t QosType) Equal(o attr.Type) bool {
	other, ok := o.(QosType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QosType) String() string {
	return "QosType"
}

func (t QosType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	egressPolicyAttribute, ok := attributes["egress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_policy is missing from object`)

		return nil, diags
	}

	egressPolicyVal, ok := egressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_policy expected to be basetypes.StringValue, was: %T`, egressPolicyAttribute))
	}

	ingressPolicyAttribute, ok := attributes["ingress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_policy is missing from object`)

		return nil, diags
	}

	ingressPolicyVal, ok := ingressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_policy expected to be basetypes.StringValue, was: %T`, ingressPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QosValue{
		EgressPolicy:  egressPolicyVal,
		IngressPolicy: ingressPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewQosValueNull() QosValue {
	return QosValue{
		state: attr.ValueStateNull,
	}
}

func NewQosValueUnknown() QosValue {
	return QosValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQosValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QosValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QosValue Attribute Value",
				"While creating a QosValue value, a missing attribute value was detected. "+
					"A QosValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QosValue Attribute Type",
				"While creating a QosValue value, an invalid attribute value was detected. "+
					"A QosValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QosValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QosValue Attribute Value",
				"While creating a QosValue value, an extra attribute value was detected. "+
					"A QosValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QosValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	egressPolicyAttribute, ok := attributes["egress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_policy is missing from object`)

		return NewQosValueUnknown(), diags
	}

	egressPolicyVal, ok := egressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_policy expected to be basetypes.StringValue, was: %T`, egressPolicyAttribute))
	}

	ingressPolicyAttribute, ok := attributes["ingress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_policy is missing from object`)

		return NewQosValueUnknown(), diags
	}

	ingressPolicyVal, ok := ingressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_policy expected to be basetypes.StringValue, was: %T`, ingressPolicyAttribute))
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	return QosValue{
		EgressPolicy:  egressPolicyVal,
		IngressPolicy: ingressPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewQosValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QosValue {
	object, diags := NewQosValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQosValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QosType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQosValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQosValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQosValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQosValueMust(QosValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QosType) ValueType(ctx context.Context) attr.Value {
	return QosValue{}
}

var _ basetypes.ObjectValuable = QosValue{}

type QosValue struct {
	EgressPolicy  basetypes.StringValue `tfsdk:"egress_policy"`
	IngressPolicy basetypes.StringValue `tfsdk:"ingress_policy"`
	state         attr.ValueState
}

func (v QosValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["egress_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ingress_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EgressPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress_policy"] = val

		val, err = v.IngressPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QosValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QosValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QosValue) String() string {
	return "QosValue"
}

func (v QosValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"egress_policy":  basetypes.StringType{},
		"ingress_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"egress_policy":  v.EgressPolicy,
			"ingress_policy": v.IngressPolicy,
		})

	return objVal, diags
}

func (v QosValue) Equal(o attr.Value) bool {
	other, ok := o.(QosValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EgressPolicy.Equal(other.EgressPolicy) {
		return false
	}

	if !v.IngressPolicy.Equal(other.IngressPolicy) {
		return false
	}

	return true
}

func (v QosValue) Type(ctx context.Context) attr.Type {
	return QosType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QosValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"egress_policy":  basetypes.StringType{},
		"ingress_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LeafsType{}

type LeafsType struct {
	basetypes.ObjectType
}

func (t LeafsType) Equal(o attr.Type) bool {
	other, ok := o.(LeafsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LeafsType) String() string {
	return "LeafsType"
}

func (t LeafsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return nil, diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	leafNodeSelectorAttribute, ok := attributes["leaf_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leaf_node_selector is missing from object`)

		return nil, diags
	}

	leafNodeSelectorVal, ok := leafNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leaf_node_selector expected to be basetypes.ListValue, was: %T`, leafNodeSelectorAttribute))
	}

	routeLeaking1Attribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking_1 is missing from object`)

		return nil, diags
	}

	routeLeaking1Val, ok := routeLeaking1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking_1 expected to be basetypes.ObjectValue, was: %T`, routeLeaking1Attribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return nil, diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return nil, diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LeafsValue{
		AsnPool:          asnPoolVal,
		LeafNodeSelector: leafNodeSelectorVal,
		RouteLeaking1:    routeLeaking1Val,
		SystemPoolIpv4:   systemPoolIpv4Val,
		SystemPoolIpv6:   systemPoolIpv6Val,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLeafsValueNull() LeafsValue {
	return LeafsValue{
		state: attr.ValueStateNull,
	}
}

func NewLeafsValueUnknown() LeafsValue {
	return LeafsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLeafsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LeafsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LeafsValue Attribute Value",
				"While creating a LeafsValue value, a missing attribute value was detected. "+
					"A LeafsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LeafsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LeafsValue Attribute Type",
				"While creating a LeafsValue value, an invalid attribute value was detected. "+
					"A LeafsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LeafsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LeafsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LeafsValue Attribute Value",
				"While creating a LeafsValue value, an extra attribute value was detected. "+
					"A LeafsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LeafsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLeafsValueUnknown(), diags
	}

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return NewLeafsValueUnknown(), diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	leafNodeSelectorAttribute, ok := attributes["leaf_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leaf_node_selector is missing from object`)

		return NewLeafsValueUnknown(), diags
	}

	leafNodeSelectorVal, ok := leafNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leaf_node_selector expected to be basetypes.ListValue, was: %T`, leafNodeSelectorAttribute))
	}

	routeLeaking1Attribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking_1 is missing from object`)

		return NewLeafsValueUnknown(), diags
	}

	routeLeaking1Val, ok := routeLeaking1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking_1 expected to be basetypes.ObjectValue, was: %T`, routeLeaking1Attribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return NewLeafsValueUnknown(), diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return NewLeafsValueUnknown(), diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	if diags.HasError() {
		return NewLeafsValueUnknown(), diags
	}

	return LeafsValue{
		AsnPool:          asnPoolVal,
		LeafNodeSelector: leafNodeSelectorVal,
		RouteLeaking1:    routeLeaking1Val,
		SystemPoolIpv4:   systemPoolIpv4Val,
		SystemPoolIpv6:   systemPoolIpv6Val,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLeafsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LeafsValue {
	object, diags := NewLeafsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLeafsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LeafsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLeafsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLeafsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLeafsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLeafsValueMust(LeafsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LeafsType) ValueType(ctx context.Context) attr.Value {
	return LeafsValue{}
}

var _ basetypes.ObjectValuable = LeafsValue{}

type LeafsValue struct {
	AsnPool          basetypes.StringValue `tfsdk:"asn_pool"`
	LeafNodeSelector basetypes.ListValue   `tfsdk:"leaf_node_selector"`
	RouteLeaking1    basetypes.ObjectValue `tfsdk:"route_leaking"`
	SystemPoolIpv4   basetypes.StringValue `tfsdk:"system_pool_ipv4"`
	SystemPoolIpv6   basetypes.StringValue `tfsdk:"system_pool_ipv6"`
	state            attr.ValueState
}

func (v LeafsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["leaf_node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["route_leaking"] = basetypes.ObjectType{
		AttrTypes: RouteLeaking1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["system_pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_pool_ipv6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AsnPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn_pool"] = val

		val, err = v.LeafNodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["leaf_node_selector"] = val

		val, err = v.RouteLeaking1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_leaking"] = val

		val, err = v.SystemPoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv4"] = val

		val, err = v.SystemPoolIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LeafsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LeafsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LeafsValue) String() string {
	return "LeafsValue"
}

func (v LeafsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var routeLeaking1 basetypes.ObjectValue

	if v.RouteLeaking1.IsNull() {
		routeLeaking1 = types.ObjectNull(
			RouteLeaking1Value{}.AttributeTypes(ctx),
		)
	}

	if v.RouteLeaking1.IsUnknown() {
		routeLeaking1 = types.ObjectUnknown(
			RouteLeaking1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteLeaking1.IsNull() && !v.RouteLeaking1.IsUnknown() {
		routeLeaking1 = types.ObjectValueMust(
			RouteLeaking1Value{}.AttributeTypes(ctx),
			v.RouteLeaking1.Attributes(),
		)
	}

	var leafNodeSelectorVal basetypes.ListValue
	switch {
	case v.LeafNodeSelector.IsUnknown():
		leafNodeSelectorVal = types.ListUnknown(types.StringType)
	case v.LeafNodeSelector.IsNull():
		leafNodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		leafNodeSelectorVal, d = types.ListValue(types.StringType, v.LeafNodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"leaf_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_leaking": basetypes.ObjectType{
				AttrTypes: RouteLeaking1Value{}.AttributeTypes(ctx),
			},
			"system_pool_ipv4": basetypes.StringType{},
			"system_pool_ipv6": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"leaf_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeaking1Value{}.AttributeTypes(ctx),
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn_pool":           v.AsnPool,
			"leaf_node_selector": leafNodeSelectorVal,
			"route_leaking":      routeLeaking1,
			"system_pool_ipv4":   v.SystemPoolIpv4,
			"system_pool_ipv6":   v.SystemPoolIpv6,
		})

	return objVal, diags
}

func (v LeafsValue) Equal(o attr.Value) bool {
	other, ok := o.(LeafsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsnPool.Equal(other.AsnPool) {
		return false
	}

	if !v.LeafNodeSelector.Equal(other.LeafNodeSelector) {
		return false
	}

	if !v.RouteLeaking1.Equal(other.RouteLeaking1) {
		return false
	}

	if !v.SystemPoolIpv4.Equal(other.SystemPoolIpv4) {
		return false
	}

	if !v.SystemPoolIpv6.Equal(other.SystemPoolIpv6) {
		return false
	}

	return true
}

func (v LeafsValue) Type(ctx context.Context) attr.Type {
	return LeafsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LeafsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"leaf_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeaking1Value{}.AttributeTypes(ctx),
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RouteLeaking1Type{}

type RouteLeaking1Type struct {
	basetypes.ObjectType
}

func (t RouteLeaking1Type) Equal(o attr.Type) bool {
	other, ok := o.(RouteLeaking1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteLeaking1Type) String() string {
	return "RouteLeaking1Type"
}

func (t RouteLeaking1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteLeaking1Value{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeaking1ValueNull() RouteLeaking1Value {
	return RouteLeaking1Value{
		state: attr.ValueStateNull,
	}
}

func NewRouteLeaking1ValueUnknown() RouteLeaking1Value {
	return RouteLeaking1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteLeaking1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteLeaking1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteLeaking1Value Attribute Value",
				"While creating a RouteLeaking1Value value, a missing attribute value was detected. "+
					"A RouteLeaking1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeaking1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteLeaking1Value Attribute Type",
				"While creating a RouteLeaking1Value value, an invalid attribute value was detected. "+
					"A RouteLeaking1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeaking1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteLeaking1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteLeaking1Value Attribute Value",
				"While creating a RouteLeaking1Value value, an extra attribute value was detected. "+
					"A RouteLeaking1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteLeaking1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteLeaking1ValueUnknown(), diags
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewRouteLeaking1ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewRouteLeaking1ValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return NewRouteLeaking1ValueUnknown(), diags
	}

	return RouteLeaking1Value{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeaking1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteLeaking1Value {
	object, diags := NewRouteLeaking1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteLeaking1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteLeaking1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteLeaking1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteLeaking1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteLeaking1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteLeaking1ValueMust(RouteLeaking1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteLeaking1Type) ValueType(ctx context.Context) attr.Value {
	return RouteLeaking1Value{}
}

var _ basetypes.ObjectValuable = RouteLeaking1Value{}

type RouteLeaking1Value struct {
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	state        attr.ValueState
}

func (v RouteLeaking1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteLeaking1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteLeaking1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteLeaking1Value) String() string {
	return "RouteLeaking1Value"
}

func (v RouteLeaking1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"export_policy": v.ExportPolicy,
			"import_policy": v.ImportPolicy,
		})

	return objVal, diags
}

func (v RouteLeaking1Value) Equal(o attr.Value) bool {
	other, ok := o.(RouteLeaking1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	return true
}

func (v RouteLeaking1Value) Type(ctx context.Context) attr.Type {
	return RouteLeaking1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteLeaking1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OverlayProtocolType{}

type OverlayProtocolType struct {
	basetypes.ObjectType
}

func (t OverlayProtocolType) Equal(o attr.Type) bool {
	other, ok := o.(OverlayProtocolType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverlayProtocolType) String() string {
	return "OverlayProtocolType"
}

func (t OverlayProtocolType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return nil, diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverlayProtocolValue{
		Bfd:      bfdVal,
		Bgp:      bgpVal,
		Protocol: protocolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewOverlayProtocolValueNull() OverlayProtocolValue {
	return OverlayProtocolValue{
		state: attr.ValueStateNull,
	}
}

func NewOverlayProtocolValueUnknown() OverlayProtocolValue {
	return OverlayProtocolValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverlayProtocolValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverlayProtocolValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverlayProtocolValue Attribute Value",
				"While creating a OverlayProtocolValue value, a missing attribute value was detected. "+
					"A OverlayProtocolValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverlayProtocolValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverlayProtocolValue Attribute Type",
				"While creating a OverlayProtocolValue value, an invalid attribute value was detected. "+
					"A OverlayProtocolValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverlayProtocolValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverlayProtocolValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverlayProtocolValue Attribute Value",
				"While creating a OverlayProtocolValue value, an extra attribute value was detected. "+
					"A OverlayProtocolValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverlayProtocolValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverlayProtocolValueUnknown(), diags
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewOverlayProtocolValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return NewOverlayProtocolValueUnknown(), diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewOverlayProtocolValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return NewOverlayProtocolValueUnknown(), diags
	}

	return OverlayProtocolValue{
		Bfd:      bfdVal,
		Bgp:      bgpVal,
		Protocol: protocolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewOverlayProtocolValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverlayProtocolValue {
	object, diags := NewOverlayProtocolValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverlayProtocolValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverlayProtocolType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverlayProtocolValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverlayProtocolValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverlayProtocolValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverlayProtocolValueMust(OverlayProtocolValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverlayProtocolType) ValueType(ctx context.Context) attr.Value {
	return OverlayProtocolValue{}
}

var _ basetypes.ObjectValuable = OverlayProtocolValue{}

type OverlayProtocolValue struct {
	Bfd      basetypes.ObjectValue `tfsdk:"bfd"`
	Bgp      basetypes.ObjectValue `tfsdk:"bgp"`
	Protocol basetypes.StringValue `tfsdk:"protocol"`
	state    attr.ValueState
}

func (v OverlayProtocolValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: BfdValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: BgpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Bgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverlayProtocolValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverlayProtocolValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverlayProtocolValue) String() string {
	return "OverlayProtocolValue"
}

func (v OverlayProtocolValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd basetypes.ObjectValue

	if v.Bfd.IsNull() {
		bfd = types.ObjectNull(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd.IsUnknown() {
		bfd = types.ObjectUnknown(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd.IsNull() && !v.Bfd.IsUnknown() {
		bfd = types.ObjectValueMust(
			BfdValue{}.AttributeTypes(ctx),
			v.Bfd.Attributes(),
		)
	}

	var bgp basetypes.ObjectValue

	if v.Bgp.IsNull() {
		bgp = types.ObjectNull(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp.IsUnknown() {
		bgp = types.ObjectUnknown(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp.IsNull() && !v.Bgp.IsUnknown() {
		bgp = types.ObjectValueMust(
			BgpValue{}.AttributeTypes(ctx),
			v.Bgp.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"protocol": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd":      bfd,
			"bgp":      bgp,
			"protocol": v.Protocol,
		})

	return objVal, diags
}

func (v OverlayProtocolValue) Equal(o attr.Value) bool {
	other, ok := o.(OverlayProtocolValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.Bgp.Equal(other.Bgp) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	return true
}

func (v OverlayProtocolValue) Type(ctx context.Context) attr.Type {
	return OverlayProtocolType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverlayProtocolValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"protocol": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BfdType{}

type BfdType struct {
	basetypes.ObjectType
}

func (t BfdType) Equal(o attr.Type) bool {
	other, ok := o.(BfdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BfdType) String() string {
	return "BfdType"
}

func (t BfdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return nil, diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return nil, diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return nil, diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return nil, diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return nil, diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueNull() BfdValue {
	return BfdValue{
		state: attr.ValueStateNull,
	}
}

func NewBfdValueUnknown() BfdValue {
	return BfdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBfdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BfdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BfdValue Attribute Value",
				"While creating a BfdValue value, a missing attribute value was detected. "+
					"A BfdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BfdValue Attribute Type",
				"While creating a BfdValue value, an invalid attribute value was detected. "+
					"A BfdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BfdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BfdValue Attribute Value",
				"While creating a BfdValue value, an extra attribute value was detected. "+
					"A BfdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BfdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BfdValue {
	object, diags := NewBfdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BfdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfdValueMust(BfdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BfdType) ValueType(ctx context.Context) attr.Value {
	return BfdValue{}
}

var _ basetypes.ObjectValuable = BfdValue{}

type BfdValue struct {
	DesiredMinTransmitInt  basetypes.Int64Value `tfsdk:"desired_min_transmit_int"`
	DetectionMultiplier    basetypes.Int64Value `tfsdk:"detection_multiplier"`
	Enabled                basetypes.BoolValue  `tfsdk:"enabled"`
	MinEchoReceiveInterval basetypes.Int64Value `tfsdk:"min_echo_receive_interval"`
	RequiredMinReceive     basetypes.Int64Value `tfsdk:"required_min_receive"`
	Ttl                    basetypes.Int64Value `tfsdk:"ttl"`
	state                  attr.ValueState
}

func (v BfdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["desired_min_transmit_int"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["detection_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_echo_receive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required_min_receive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ttl"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DesiredMinTransmitInt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_min_transmit_int"] = val

		val, err = v.DetectionMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detection_multiplier"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MinEchoReceiveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_echo_receive_interval"] = val

		val, err = v.RequiredMinReceive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_min_receive"] = val

		val, err = v.Ttl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ttl"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BfdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BfdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BfdValue) String() string {
	return "BfdValue"
}

func (v BfdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"desired_min_transmit_int":  v.DesiredMinTransmitInt,
			"detection_multiplier":      v.DetectionMultiplier,
			"enabled":                   v.Enabled,
			"min_echo_receive_interval": v.MinEchoReceiveInterval,
			"required_min_receive":      v.RequiredMinReceive,
			"ttl":                       v.Ttl,
		})

	return objVal, diags
}

func (v BfdValue) Equal(o attr.Value) bool {
	other, ok := o.(BfdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DesiredMinTransmitInt.Equal(other.DesiredMinTransmitInt) {
		return false
	}

	if !v.DetectionMultiplier.Equal(other.DetectionMultiplier) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MinEchoReceiveInterval.Equal(other.MinEchoReceiveInterval) {
		return false
	}

	if !v.RequiredMinReceive.Equal(other.RequiredMinReceive) {
		return false
	}

	if !v.Ttl.Equal(other.Ttl) {
		return false
	}

	return true
}

func (v BfdValue) Type(ctx context.Context) attr.Type {
	return BfdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BfdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BgpType{}

type BgpType struct {
	basetypes.ObjectType
}

func (t BgpType) Equal(o attr.Type) bool {
	other, ok := o.(BgpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpType) String() string {
	return "BgpType"
}

func (t BgpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return nil, diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	rrClientNodeSelectorAttribute, ok := attributes["rr_client_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rr_client_node_selector is missing from object`)

		return nil, diags
	}

	rrClientNodeSelectorVal, ok := rrClientNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rr_client_node_selector expected to be basetypes.ListValue, was: %T`, rrClientNodeSelectorAttribute))
	}

	rrIpAddressesAttribute, ok := attributes["rr_ip_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rr_ip_addresses is missing from object`)

		return nil, diags
	}

	rrIpAddressesVal, ok := rrIpAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rr_ip_addresses expected to be basetypes.ListValue, was: %T`, rrIpAddressesAttribute))
	}

	rrNodeSelectorAttribute, ok := attributes["rr_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rr_node_selector is missing from object`)

		return nil, diags
	}

	rrNodeSelectorVal, ok := rrNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rr_node_selector expected to be basetypes.ListValue, was: %T`, rrNodeSelectorAttribute))
	}

	timersAttribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers is missing from object`)

		return nil, diags
	}

	timersVal, ok := timersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers expected to be basetypes.ObjectValue, was: %T`, timersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpValue{
		AutonomousSystem:     autonomousSystemVal,
		ClusterId:            clusterIdVal,
		ExportPolicy:         exportPolicyVal,
		ImportPolicy:         importPolicyVal,
		Keychain:             keychainVal,
		RrClientNodeSelector: rrClientNodeSelectorVal,
		RrIpAddresses:        rrIpAddressesVal,
		RrNodeSelector:       rrNodeSelectorVal,
		Timers:               timersVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBgpValueNull() BgpValue {
	return BgpValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpValueUnknown() BgpValue {
	return BgpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpValue Attribute Value",
				"While creating a BgpValue value, a missing attribute value was detected. "+
					"A BgpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpValue Attribute Type",
				"While creating a BgpValue value, an invalid attribute value was detected. "+
					"A BgpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpValue Attribute Value",
				"While creating a BgpValue value, an extra attribute value was detected. "+
					"A BgpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	rrClientNodeSelectorAttribute, ok := attributes["rr_client_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rr_client_node_selector is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	rrClientNodeSelectorVal, ok := rrClientNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rr_client_node_selector expected to be basetypes.ListValue, was: %T`, rrClientNodeSelectorAttribute))
	}

	rrIpAddressesAttribute, ok := attributes["rr_ip_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rr_ip_addresses is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	rrIpAddressesVal, ok := rrIpAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rr_ip_addresses expected to be basetypes.ListValue, was: %T`, rrIpAddressesAttribute))
	}

	rrNodeSelectorAttribute, ok := attributes["rr_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rr_node_selector is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	rrNodeSelectorVal, ok := rrNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rr_node_selector expected to be basetypes.ListValue, was: %T`, rrNodeSelectorAttribute))
	}

	timersAttribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	timersVal, ok := timersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers expected to be basetypes.ObjectValue, was: %T`, timersAttribute))
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	return BgpValue{
		AutonomousSystem:     autonomousSystemVal,
		ClusterId:            clusterIdVal,
		ExportPolicy:         exportPolicyVal,
		ImportPolicy:         importPolicyVal,
		Keychain:             keychainVal,
		RrClientNodeSelector: rrClientNodeSelectorVal,
		RrIpAddresses:        rrIpAddressesVal,
		RrNodeSelector:       rrNodeSelectorVal,
		Timers:               timersVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBgpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpValue {
	object, diags := NewBgpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpValueMust(BgpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpType) ValueType(ctx context.Context) attr.Value {
	return BgpValue{}
}

var _ basetypes.ObjectValuable = BgpValue{}

type BgpValue struct {
	AutonomousSystem     basetypes.Int64Value  `tfsdk:"autonomous_system"`
	ClusterId            basetypes.StringValue `tfsdk:"cluster_id"`
	ExportPolicy         basetypes.ListValue   `tfsdk:"export_policy"`
	ImportPolicy         basetypes.ListValue   `tfsdk:"import_policy"`
	Keychain             basetypes.StringValue `tfsdk:"keychain"`
	RrClientNodeSelector basetypes.ListValue   `tfsdk:"rr_client_node_selector"`
	RrIpAddresses        basetypes.ListValue   `tfsdk:"rr_ip_addresses"`
	RrNodeSelector       basetypes.ListValue   `tfsdk:"rr_node_selector"`
	Timers               basetypes.ObjectValue `tfsdk:"timers"`
	state                attr.ValueState
}

func (v BgpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cluster_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rr_client_node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["rr_ip_addresses"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["rr_node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["timers"] = basetypes.ObjectType{
		AttrTypes: TimersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		val, err = v.ClusterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_id"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.RrClientNodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rr_client_node_selector"] = val

		val, err = v.RrIpAddresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rr_ip_addresses"] = val

		val, err = v.RrNodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rr_node_selector"] = val

		val, err = v.Timers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpValue) String() string {
	return "BgpValue"
}

func (v BgpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var timers basetypes.ObjectValue

	if v.Timers.IsNull() {
		timers = types.ObjectNull(
			TimersValue{}.AttributeTypes(ctx),
		)
	}

	if v.Timers.IsUnknown() {
		timers = types.ObjectUnknown(
			TimersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Timers.IsNull() && !v.Timers.IsUnknown() {
		timers = types.ObjectValueMust(
			TimersValue{}.AttributeTypes(ctx),
			v.Timers.Attributes(),
		)
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"autonomous_system": basetypes.Int64Type{},
			"cluster_id":        basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain": basetypes.StringType{},
			"rr_client_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_ip_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"autonomous_system": basetypes.Int64Type{},
			"cluster_id":        basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain": basetypes.StringType{},
			"rr_client_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_ip_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var rrClientNodeSelectorVal basetypes.ListValue
	switch {
	case v.RrClientNodeSelector.IsUnknown():
		rrClientNodeSelectorVal = types.ListUnknown(types.StringType)
	case v.RrClientNodeSelector.IsNull():
		rrClientNodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		rrClientNodeSelectorVal, d = types.ListValue(types.StringType, v.RrClientNodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"autonomous_system": basetypes.Int64Type{},
			"cluster_id":        basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain": basetypes.StringType{},
			"rr_client_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_ip_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var rrIpAddressesVal basetypes.ListValue
	switch {
	case v.RrIpAddresses.IsUnknown():
		rrIpAddressesVal = types.ListUnknown(types.StringType)
	case v.RrIpAddresses.IsNull():
		rrIpAddressesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		rrIpAddressesVal, d = types.ListValue(types.StringType, v.RrIpAddresses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"autonomous_system": basetypes.Int64Type{},
			"cluster_id":        basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain": basetypes.StringType{},
			"rr_client_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_ip_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var rrNodeSelectorVal basetypes.ListValue
	switch {
	case v.RrNodeSelector.IsUnknown():
		rrNodeSelectorVal = types.ListUnknown(types.StringType)
	case v.RrNodeSelector.IsNull():
		rrNodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		rrNodeSelectorVal, d = types.ListValue(types.StringType, v.RrNodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"autonomous_system": basetypes.Int64Type{},
			"cluster_id":        basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain": basetypes.StringType{},
			"rr_client_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_ip_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rr_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"cluster_id":        basetypes.StringType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"keychain": basetypes.StringType{},
		"rr_client_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"rr_ip_addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
		"rr_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"timers": basetypes.ObjectType{
			AttrTypes: TimersValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system":       v.AutonomousSystem,
			"cluster_id":              v.ClusterId,
			"export_policy":           exportPolicyVal,
			"import_policy":           importPolicyVal,
			"keychain":                v.Keychain,
			"rr_client_node_selector": rrClientNodeSelectorVal,
			"rr_ip_addresses":         rrIpAddressesVal,
			"rr_node_selector":        rrNodeSelectorVal,
			"timers":                  timers,
		})

	return objVal, diags
}

func (v BgpValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	if !v.ClusterId.Equal(other.ClusterId) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.RrClientNodeSelector.Equal(other.RrClientNodeSelector) {
		return false
	}

	if !v.RrIpAddresses.Equal(other.RrIpAddresses) {
		return false
	}

	if !v.RrNodeSelector.Equal(other.RrNodeSelector) {
		return false
	}

	if !v.Timers.Equal(other.Timers) {
		return false
	}

	return true
}

func (v BgpValue) Type(ctx context.Context) attr.Type {
	return BgpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"cluster_id":        basetypes.StringType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"keychain": basetypes.StringType{},
		"rr_client_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"rr_ip_addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
		"rr_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"timers": basetypes.ObjectType{
			AttrTypes: TimersValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = TimersType{}

type TimersType struct {
	basetypes.ObjectType
}

func (t TimersType) Equal(o attr.Type) bool {
	other, ok := o.(TimersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimersType) String() string {
	return "TimersType"
}

func (t TimersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return nil, diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return nil, diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return nil, diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TimersValue{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimersValueNull() TimersValue {
	return TimersValue{
		state: attr.ValueStateNull,
	}
}

func NewTimersValueUnknown() TimersValue {
	return TimersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimersValue Attribute Value",
				"While creating a TimersValue value, a missing attribute value was detected. "+
					"A TimersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimersValue Attribute Type",
				"While creating a TimersValue value, an invalid attribute value was detected. "+
					"A TimersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimersValue Attribute Value",
				"While creating a TimersValue value, an extra attribute value was detected. "+
					"A TimersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimersValueUnknown(), diags
	}

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return NewTimersValueUnknown(), diags
	}

	return TimersValue{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimersValue {
	object, diags := NewTimersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimersValueMust(TimersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimersType) ValueType(ctx context.Context) attr.Value {
	return TimersValue{}
}

var _ basetypes.ObjectValuable = TimersValue{}

type TimersValue struct {
	ConnectRetry                 basetypes.Int64Value `tfsdk:"connect_retry"`
	HoldTime                     basetypes.Int64Value `tfsdk:"hold_time"`
	KeepAlive                    basetypes.Int64Value `tfsdk:"keep_alive"`
	MinimumAdvertisementInterval basetypes.Int64Value `tfsdk:"minimum_advertisement_interval"`
	state                        attr.ValueState
}

func (v TimersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["connect_retry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_alive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimum_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConnectRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connect_retry"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.KeepAlive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_alive"] = val

		val, err = v.MinimumAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_advertisement_interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimersValue) String() string {
	return "TimersValue"
}

func (v TimersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connect_retry":                  v.ConnectRetry,
			"hold_time":                      v.HoldTime,
			"keep_alive":                     v.KeepAlive,
			"minimum_advertisement_interval": v.MinimumAdvertisementInterval,
		})

	return objVal, diags
}

func (v TimersValue) Equal(o attr.Value) bool {
	other, ok := o.(TimersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectRetry.Equal(other.ConnectRetry) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.KeepAlive.Equal(other.KeepAlive) {
		return false
	}

	if !v.MinimumAdvertisementInterval.Equal(other.MinimumAdvertisementInterval) {
		return false
	}

	return true
}

func (v TimersValue) Type(ctx context.Context) attr.Type {
	return TimersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RouteLeaking2Type{}

type RouteLeaking2Type struct {
	basetypes.ObjectType
}

func (t RouteLeaking2Type) Equal(o attr.Type) bool {
	other, ok := o.(RouteLeaking2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteLeaking2Type) String() string {
	return "RouteLeaking2Type"
}

func (t RouteLeaking2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteLeaking2Value{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeaking2ValueNull() RouteLeaking2Value {
	return RouteLeaking2Value{
		state: attr.ValueStateNull,
	}
}

func NewRouteLeaking2ValueUnknown() RouteLeaking2Value {
	return RouteLeaking2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteLeaking2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteLeaking2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteLeaking2Value Attribute Value",
				"While creating a RouteLeaking2Value value, a missing attribute value was detected. "+
					"A RouteLeaking2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeaking2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteLeaking2Value Attribute Type",
				"While creating a RouteLeaking2Value value, an invalid attribute value was detected. "+
					"A RouteLeaking2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeaking2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteLeaking2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteLeaking2Value Attribute Value",
				"While creating a RouteLeaking2Value value, an extra attribute value was detected. "+
					"A RouteLeaking2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteLeaking2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteLeaking2ValueUnknown(), diags
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewRouteLeaking2ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewRouteLeaking2ValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return NewRouteLeaking2ValueUnknown(), diags
	}

	return RouteLeaking2Value{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeaking2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteLeaking2Value {
	object, diags := NewRouteLeaking2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteLeaking2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteLeaking2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteLeaking2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteLeaking2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteLeaking2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteLeaking2ValueMust(RouteLeaking2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteLeaking2Type) ValueType(ctx context.Context) attr.Value {
	return RouteLeaking2Value{}
}

var _ basetypes.ObjectValuable = RouteLeaking2Value{}

type RouteLeaking2Value struct {
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	state        attr.ValueState
}

func (v RouteLeaking2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteLeaking2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteLeaking2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteLeaking2Value) String() string {
	return "RouteLeaking2Value"
}

func (v RouteLeaking2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"export_policy": v.ExportPolicy,
			"import_policy": v.ImportPolicy,
		})

	return objVal, diags
}

func (v RouteLeaking2Value) Equal(o attr.Value) bool {
	other, ok := o.(RouteLeaking2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	return true
}

func (v RouteLeaking2Value) Type(ctx context.Context) attr.Type {
	return RouteLeaking2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteLeaking2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpinesType{}

type SpinesType struct {
	basetypes.ObjectType
}

func (t SpinesType) Equal(o attr.Type) bool {
	other, ok := o.(SpinesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpinesType) String() string {
	return "SpinesType"
}

func (t SpinesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return nil, diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	routeLeaking3Attribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking_3 is missing from object`)

		return nil, diags
	}

	routeLeaking3Val, ok := routeLeaking3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking_3 expected to be basetypes.ObjectValue, was: %T`, routeLeaking3Attribute))
	}

	spineNodeSelectorAttribute, ok := attributes["spine_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spine_node_selector is missing from object`)

		return nil, diags
	}

	spineNodeSelectorVal, ok := spineNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spine_node_selector expected to be basetypes.ListValue, was: %T`, spineNodeSelectorAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return nil, diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return nil, diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpinesValue{
		AsnPool:           asnPoolVal,
		RouteLeaking3:     routeLeaking3Val,
		SpineNodeSelector: spineNodeSelectorVal,
		SystemPoolIpv4:    systemPoolIpv4Val,
		SystemPoolIpv6:    systemPoolIpv6Val,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpinesValueNull() SpinesValue {
	return SpinesValue{
		state: attr.ValueStateNull,
	}
}

func NewSpinesValueUnknown() SpinesValue {
	return SpinesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpinesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpinesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpinesValue Attribute Value",
				"While creating a SpinesValue value, a missing attribute value was detected. "+
					"A SpinesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpinesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpinesValue Attribute Type",
				"While creating a SpinesValue value, an invalid attribute value was detected. "+
					"A SpinesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpinesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpinesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpinesValue Attribute Value",
				"While creating a SpinesValue value, an extra attribute value was detected. "+
					"A SpinesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpinesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpinesValueUnknown(), diags
	}

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return NewSpinesValueUnknown(), diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	routeLeaking3Attribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking_3 is missing from object`)

		return NewSpinesValueUnknown(), diags
	}

	routeLeaking3Val, ok := routeLeaking3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking_3 expected to be basetypes.ObjectValue, was: %T`, routeLeaking3Attribute))
	}

	spineNodeSelectorAttribute, ok := attributes["spine_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spine_node_selector is missing from object`)

		return NewSpinesValueUnknown(), diags
	}

	spineNodeSelectorVal, ok := spineNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spine_node_selector expected to be basetypes.ListValue, was: %T`, spineNodeSelectorAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return NewSpinesValueUnknown(), diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return NewSpinesValueUnknown(), diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	if diags.HasError() {
		return NewSpinesValueUnknown(), diags
	}

	return SpinesValue{
		AsnPool:           asnPoolVal,
		RouteLeaking3:     routeLeaking3Val,
		SpineNodeSelector: spineNodeSelectorVal,
		SystemPoolIpv4:    systemPoolIpv4Val,
		SystemPoolIpv6:    systemPoolIpv6Val,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpinesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpinesValue {
	object, diags := NewSpinesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpinesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpinesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpinesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpinesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpinesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpinesValueMust(SpinesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpinesType) ValueType(ctx context.Context) attr.Value {
	return SpinesValue{}
}

var _ basetypes.ObjectValuable = SpinesValue{}

type SpinesValue struct {
	AsnPool           basetypes.StringValue `tfsdk:"asn_pool"`
	RouteLeaking3     basetypes.ObjectValue `tfsdk:"route_leaking"`
	SpineNodeSelector basetypes.ListValue   `tfsdk:"spine_node_selector"`
	SystemPoolIpv4    basetypes.StringValue `tfsdk:"system_pool_ipv4"`
	SystemPoolIpv6    basetypes.StringValue `tfsdk:"system_pool_ipv6"`
	state             attr.ValueState
}

func (v SpinesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["route_leaking"] = basetypes.ObjectType{
		AttrTypes: RouteLeaking3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spine_node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["system_pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_pool_ipv6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AsnPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn_pool"] = val

		val, err = v.RouteLeaking3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_leaking"] = val

		val, err = v.SpineNodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spine_node_selector"] = val

		val, err = v.SystemPoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv4"] = val

		val, err = v.SystemPoolIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpinesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpinesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpinesValue) String() string {
	return "SpinesValue"
}

func (v SpinesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var routeLeaking3 basetypes.ObjectValue

	if v.RouteLeaking3.IsNull() {
		routeLeaking3 = types.ObjectNull(
			RouteLeaking3Value{}.AttributeTypes(ctx),
		)
	}

	if v.RouteLeaking3.IsUnknown() {
		routeLeaking3 = types.ObjectUnknown(
			RouteLeaking3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteLeaking3.IsNull() && !v.RouteLeaking3.IsUnknown() {
		routeLeaking3 = types.ObjectValueMust(
			RouteLeaking3Value{}.AttributeTypes(ctx),
			v.RouteLeaking3.Attributes(),
		)
	}

	var spineNodeSelectorVal basetypes.ListValue
	switch {
	case v.SpineNodeSelector.IsUnknown():
		spineNodeSelectorVal = types.ListUnknown(types.StringType)
	case v.SpineNodeSelector.IsNull():
		spineNodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		spineNodeSelectorVal, d = types.ListValue(types.StringType, v.SpineNodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"route_leaking": basetypes.ObjectType{
				AttrTypes: RouteLeaking3Value{}.AttributeTypes(ctx),
			},
			"spine_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_pool_ipv4": basetypes.StringType{},
			"system_pool_ipv6": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeaking3Value{}.AttributeTypes(ctx),
		},
		"spine_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn_pool":            v.AsnPool,
			"route_leaking":       routeLeaking3,
			"spine_node_selector": spineNodeSelectorVal,
			"system_pool_ipv4":    v.SystemPoolIpv4,
			"system_pool_ipv6":    v.SystemPoolIpv6,
		})

	return objVal, diags
}

func (v SpinesValue) Equal(o attr.Value) bool {
	other, ok := o.(SpinesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsnPool.Equal(other.AsnPool) {
		return false
	}

	if !v.RouteLeaking3.Equal(other.RouteLeaking3) {
		return false
	}

	if !v.SpineNodeSelector.Equal(other.SpineNodeSelector) {
		return false
	}

	if !v.SystemPoolIpv4.Equal(other.SystemPoolIpv4) {
		return false
	}

	if !v.SystemPoolIpv6.Equal(other.SystemPoolIpv6) {
		return false
	}

	return true
}

func (v SpinesValue) Type(ctx context.Context) attr.Type {
	return SpinesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpinesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeaking3Value{}.AttributeTypes(ctx),
		},
		"spine_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RouteLeaking3Type{}

type RouteLeaking3Type struct {
	basetypes.ObjectType
}

func (t RouteLeaking3Type) Equal(o attr.Type) bool {
	other, ok := o.(RouteLeaking3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteLeaking3Type) String() string {
	return "RouteLeaking3Type"
}

func (t RouteLeaking3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteLeaking3Value{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeaking3ValueNull() RouteLeaking3Value {
	return RouteLeaking3Value{
		state: attr.ValueStateNull,
	}
}

func NewRouteLeaking3ValueUnknown() RouteLeaking3Value {
	return RouteLeaking3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteLeaking3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteLeaking3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteLeaking3Value Attribute Value",
				"While creating a RouteLeaking3Value value, a missing attribute value was detected. "+
					"A RouteLeaking3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeaking3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteLeaking3Value Attribute Type",
				"While creating a RouteLeaking3Value value, an invalid attribute value was detected. "+
					"A RouteLeaking3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeaking3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteLeaking3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteLeaking3Value Attribute Value",
				"While creating a RouteLeaking3Value value, an extra attribute value was detected. "+
					"A RouteLeaking3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteLeaking3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteLeaking3ValueUnknown(), diags
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewRouteLeaking3ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewRouteLeaking3ValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return NewRouteLeaking3ValueUnknown(), diags
	}

	return RouteLeaking3Value{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeaking3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteLeaking3Value {
	object, diags := NewRouteLeaking3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteLeaking3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteLeaking3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteLeaking3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteLeaking3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteLeaking3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteLeaking3ValueMust(RouteLeaking3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteLeaking3Type) ValueType(ctx context.Context) attr.Value {
	return RouteLeaking3Value{}
}

var _ basetypes.ObjectValuable = RouteLeaking3Value{}

type RouteLeaking3Value struct {
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	state        attr.ValueState
}

func (v RouteLeaking3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteLeaking3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteLeaking3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteLeaking3Value) String() string {
	return "RouteLeaking3Value"
}

func (v RouteLeaking3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"export_policy": v.ExportPolicy,
			"import_policy": v.ImportPolicy,
		})

	return objVal, diags
}

func (v RouteLeaking3Value) Equal(o attr.Value) bool {
	other, ok := o.(RouteLeaking3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	return true
}

func (v RouteLeaking3Value) Type(ctx context.Context) attr.Type {
	return RouteLeaking3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteLeaking3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SuperSpinesType{}

type SuperSpinesType struct {
	basetypes.ObjectType
}

func (t SuperSpinesType) Equal(o attr.Type) bool {
	other, ok := o.(SuperSpinesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SuperSpinesType) String() string {
	return "SuperSpinesType"
}

func (t SuperSpinesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return nil, diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	routeLeaking4Attribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking_4 is missing from object`)

		return nil, diags
	}

	routeLeaking4Val, ok := routeLeaking4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking_4 expected to be basetypes.ObjectValue, was: %T`, routeLeaking4Attribute))
	}

	superSpineNodeSelectorAttribute, ok := attributes["super_spine_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`super_spine_node_selector is missing from object`)

		return nil, diags
	}

	superSpineNodeSelectorVal, ok := superSpineNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`super_spine_node_selector expected to be basetypes.ListValue, was: %T`, superSpineNodeSelectorAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return nil, diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return nil, diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SuperSpinesValue{
		AsnPool:                asnPoolVal,
		RouteLeaking4:          routeLeaking4Val,
		SuperSpineNodeSelector: superSpineNodeSelectorVal,
		SystemPoolIpv4:         systemPoolIpv4Val,
		SystemPoolIpv6:         systemPoolIpv6Val,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSuperSpinesValueNull() SuperSpinesValue {
	return SuperSpinesValue{
		state: attr.ValueStateNull,
	}
}

func NewSuperSpinesValueUnknown() SuperSpinesValue {
	return SuperSpinesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSuperSpinesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SuperSpinesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SuperSpinesValue Attribute Value",
				"While creating a SuperSpinesValue value, a missing attribute value was detected. "+
					"A SuperSpinesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SuperSpinesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SuperSpinesValue Attribute Type",
				"While creating a SuperSpinesValue value, an invalid attribute value was detected. "+
					"A SuperSpinesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SuperSpinesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SuperSpinesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SuperSpinesValue Attribute Value",
				"While creating a SuperSpinesValue value, an extra attribute value was detected. "+
					"A SuperSpinesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SuperSpinesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSuperSpinesValueUnknown(), diags
	}

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return NewSuperSpinesValueUnknown(), diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	routeLeaking4Attribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking_4 is missing from object`)

		return NewSuperSpinesValueUnknown(), diags
	}

	routeLeaking4Val, ok := routeLeaking4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking_4 expected to be basetypes.ObjectValue, was: %T`, routeLeaking4Attribute))
	}

	superSpineNodeSelectorAttribute, ok := attributes["super_spine_node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`super_spine_node_selector is missing from object`)

		return NewSuperSpinesValueUnknown(), diags
	}

	superSpineNodeSelectorVal, ok := superSpineNodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`super_spine_node_selector expected to be basetypes.ListValue, was: %T`, superSpineNodeSelectorAttribute))
	}

	systemPoolIpv4Attribute, ok := attributes["system_pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv4 is missing from object`)

		return NewSuperSpinesValueUnknown(), diags
	}

	systemPoolIpv4Val, ok := systemPoolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv4 expected to be basetypes.StringValue, was: %T`, systemPoolIpv4Attribute))
	}

	systemPoolIpv6Attribute, ok := attributes["system_pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_pool_ipv6 is missing from object`)

		return NewSuperSpinesValueUnknown(), diags
	}

	systemPoolIpv6Val, ok := systemPoolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_pool_ipv6 expected to be basetypes.StringValue, was: %T`, systemPoolIpv6Attribute))
	}

	if diags.HasError() {
		return NewSuperSpinesValueUnknown(), diags
	}

	return SuperSpinesValue{
		AsnPool:                asnPoolVal,
		RouteLeaking4:          routeLeaking4Val,
		SuperSpineNodeSelector: superSpineNodeSelectorVal,
		SystemPoolIpv4:         systemPoolIpv4Val,
		SystemPoolIpv6:         systemPoolIpv6Val,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSuperSpinesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SuperSpinesValue {
	object, diags := NewSuperSpinesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSuperSpinesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SuperSpinesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSuperSpinesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSuperSpinesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSuperSpinesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSuperSpinesValueMust(SuperSpinesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SuperSpinesType) ValueType(ctx context.Context) attr.Value {
	return SuperSpinesValue{}
}

var _ basetypes.ObjectValuable = SuperSpinesValue{}

type SuperSpinesValue struct {
	AsnPool                basetypes.StringValue `tfsdk:"asn_pool"`
	RouteLeaking4          basetypes.ObjectValue `tfsdk:"route_leaking"`
	SuperSpineNodeSelector basetypes.ListValue   `tfsdk:"super_spine_node_selector"`
	SystemPoolIpv4         basetypes.StringValue `tfsdk:"system_pool_ipv4"`
	SystemPoolIpv6         basetypes.StringValue `tfsdk:"system_pool_ipv6"`
	state                  attr.ValueState
}

func (v SuperSpinesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["route_leaking"] = basetypes.ObjectType{
		AttrTypes: RouteLeaking4Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["super_spine_node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["system_pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_pool_ipv6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AsnPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn_pool"] = val

		val, err = v.RouteLeaking4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_leaking"] = val

		val, err = v.SuperSpineNodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["super_spine_node_selector"] = val

		val, err = v.SystemPoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv4"] = val

		val, err = v.SystemPoolIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_pool_ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SuperSpinesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SuperSpinesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SuperSpinesValue) String() string {
	return "SuperSpinesValue"
}

func (v SuperSpinesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var routeLeaking4 basetypes.ObjectValue

	if v.RouteLeaking4.IsNull() {
		routeLeaking4 = types.ObjectNull(
			RouteLeaking4Value{}.AttributeTypes(ctx),
		)
	}

	if v.RouteLeaking4.IsUnknown() {
		routeLeaking4 = types.ObjectUnknown(
			RouteLeaking4Value{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteLeaking4.IsNull() && !v.RouteLeaking4.IsUnknown() {
		routeLeaking4 = types.ObjectValueMust(
			RouteLeaking4Value{}.AttributeTypes(ctx),
			v.RouteLeaking4.Attributes(),
		)
	}

	var superSpineNodeSelectorVal basetypes.ListValue
	switch {
	case v.SuperSpineNodeSelector.IsUnknown():
		superSpineNodeSelectorVal = types.ListUnknown(types.StringType)
	case v.SuperSpineNodeSelector.IsNull():
		superSpineNodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		superSpineNodeSelectorVal, d = types.ListValue(types.StringType, v.SuperSpineNodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"route_leaking": basetypes.ObjectType{
				AttrTypes: RouteLeaking4Value{}.AttributeTypes(ctx),
			},
			"super_spine_node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"system_pool_ipv4": basetypes.StringType{},
			"system_pool_ipv6": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeaking4Value{}.AttributeTypes(ctx),
		},
		"super_spine_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn_pool":                  v.AsnPool,
			"route_leaking":             routeLeaking4,
			"super_spine_node_selector": superSpineNodeSelectorVal,
			"system_pool_ipv4":          v.SystemPoolIpv4,
			"system_pool_ipv6":          v.SystemPoolIpv6,
		})

	return objVal, diags
}

func (v SuperSpinesValue) Equal(o attr.Value) bool {
	other, ok := o.(SuperSpinesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsnPool.Equal(other.AsnPool) {
		return false
	}

	if !v.RouteLeaking4.Equal(other.RouteLeaking4) {
		return false
	}

	if !v.SuperSpineNodeSelector.Equal(other.SuperSpineNodeSelector) {
		return false
	}

	if !v.SystemPoolIpv4.Equal(other.SystemPoolIpv4) {
		return false
	}

	if !v.SystemPoolIpv6.Equal(other.SystemPoolIpv6) {
		return false
	}

	return true
}

func (v SuperSpinesValue) Type(ctx context.Context) attr.Type {
	return SuperSpinesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SuperSpinesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeaking4Value{}.AttributeTypes(ctx),
		},
		"super_spine_node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"system_pool_ipv4": basetypes.StringType{},
		"system_pool_ipv6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RouteLeaking4Type{}

type RouteLeaking4Type struct {
	basetypes.ObjectType
}

func (t RouteLeaking4Type) Equal(o attr.Type) bool {
	other, ok := o.(RouteLeaking4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteLeaking4Type) String() string {
	return "RouteLeaking4Type"
}

func (t RouteLeaking4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteLeaking4Value{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeaking4ValueNull() RouteLeaking4Value {
	return RouteLeaking4Value{
		state: attr.ValueStateNull,
	}
}

func NewRouteLeaking4ValueUnknown() RouteLeaking4Value {
	return RouteLeaking4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteLeaking4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteLeaking4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteLeaking4Value Attribute Value",
				"While creating a RouteLeaking4Value value, a missing attribute value was detected. "+
					"A RouteLeaking4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeaking4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteLeaking4Value Attribute Type",
				"While creating a RouteLeaking4Value value, an invalid attribute value was detected. "+
					"A RouteLeaking4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeaking4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteLeaking4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteLeaking4Value Attribute Value",
				"While creating a RouteLeaking4Value value, an extra attribute value was detected. "+
					"A RouteLeaking4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteLeaking4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteLeaking4ValueUnknown(), diags
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewRouteLeaking4ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewRouteLeaking4ValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return NewRouteLeaking4ValueUnknown(), diags
	}

	return RouteLeaking4Value{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeaking4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteLeaking4Value {
	object, diags := NewRouteLeaking4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteLeaking4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteLeaking4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteLeaking4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteLeaking4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteLeaking4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteLeaking4ValueMust(RouteLeaking4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteLeaking4Type) ValueType(ctx context.Context) attr.Value {
	return RouteLeaking4Value{}
}

var _ basetypes.ObjectValuable = RouteLeaking4Value{}

type RouteLeaking4Value struct {
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	state        attr.ValueState
}

func (v RouteLeaking4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteLeaking4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteLeaking4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteLeaking4Value) String() string {
	return "RouteLeaking4Value"
}

func (v RouteLeaking4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"export_policy": v.ExportPolicy,
			"import_policy": v.ImportPolicy,
		})

	return objVal, diags
}

func (v RouteLeaking4Value) Equal(o attr.Value) bool {
	other, ok := o.(RouteLeaking4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	return true
}

func (v RouteLeaking4Value) Type(ctx context.Context) attr.Type {
	return RouteLeaking4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteLeaking4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = UnderlayProtocolType{}

type UnderlayProtocolType struct {
	basetypes.ObjectType
}

func (t UnderlayProtocolType) Equal(o attr.Type) bool {
	other, ok := o.(UnderlayProtocolType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UnderlayProtocolType) String() string {
	return "UnderlayProtocolType"
}

func (t UnderlayProtocolType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfd1Attribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_1 is missing from object`)

		return nil, diags
	}

	bfd1Val, ok := bfd1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_1 expected to be basetypes.ObjectValue, was: %T`, bfd1Attribute))
	}

	bgp1Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_1 is missing from object`)

		return nil, diags
	}

	bgp1Val, ok := bgp1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_1 expected to be basetypes.ObjectValue, was: %T`, bgp1Attribute))
	}

	ospfAttribute, ok := attributes["ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf is missing from object`)

		return nil, diags
	}

	ospfVal, ok := ospfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf expected to be basetypes.ObjectValue, was: %T`, ospfAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.ListValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UnderlayProtocolValue{
		Bfd1:     bfd1Val,
		Bgp1:     bgp1Val,
		Ospf:     ospfVal,
		Protocol: protocolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewUnderlayProtocolValueNull() UnderlayProtocolValue {
	return UnderlayProtocolValue{
		state: attr.ValueStateNull,
	}
}

func NewUnderlayProtocolValueUnknown() UnderlayProtocolValue {
	return UnderlayProtocolValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUnderlayProtocolValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UnderlayProtocolValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UnderlayProtocolValue Attribute Value",
				"While creating a UnderlayProtocolValue value, a missing attribute value was detected. "+
					"A UnderlayProtocolValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UnderlayProtocolValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UnderlayProtocolValue Attribute Type",
				"While creating a UnderlayProtocolValue value, an invalid attribute value was detected. "+
					"A UnderlayProtocolValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UnderlayProtocolValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UnderlayProtocolValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UnderlayProtocolValue Attribute Value",
				"While creating a UnderlayProtocolValue value, an extra attribute value was detected. "+
					"A UnderlayProtocolValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UnderlayProtocolValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUnderlayProtocolValueUnknown(), diags
	}

	bfd1Attribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_1 is missing from object`)

		return NewUnderlayProtocolValueUnknown(), diags
	}

	bfd1Val, ok := bfd1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_1 expected to be basetypes.ObjectValue, was: %T`, bfd1Attribute))
	}

	bgp1Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_1 is missing from object`)

		return NewUnderlayProtocolValueUnknown(), diags
	}

	bgp1Val, ok := bgp1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_1 expected to be basetypes.ObjectValue, was: %T`, bgp1Attribute))
	}

	ospfAttribute, ok := attributes["ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf is missing from object`)

		return NewUnderlayProtocolValueUnknown(), diags
	}

	ospfVal, ok := ospfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf expected to be basetypes.ObjectValue, was: %T`, ospfAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewUnderlayProtocolValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.ListValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return NewUnderlayProtocolValueUnknown(), diags
	}

	return UnderlayProtocolValue{
		Bfd1:     bfd1Val,
		Bgp1:     bgp1Val,
		Ospf:     ospfVal,
		Protocol: protocolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewUnderlayProtocolValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UnderlayProtocolValue {
	object, diags := NewUnderlayProtocolValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUnderlayProtocolValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UnderlayProtocolType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUnderlayProtocolValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUnderlayProtocolValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUnderlayProtocolValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUnderlayProtocolValueMust(UnderlayProtocolValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UnderlayProtocolType) ValueType(ctx context.Context) attr.Value {
	return UnderlayProtocolValue{}
}

var _ basetypes.ObjectValuable = UnderlayProtocolValue{}

type UnderlayProtocolValue struct {
	Bfd1     basetypes.ObjectValue `tfsdk:"bfd"`
	Bgp1     basetypes.ObjectValue `tfsdk:"bgp"`
	Ospf     basetypes.ObjectValue `tfsdk:"ospf"`
	Protocol basetypes.ListValue   `tfsdk:"protocol"`
	state    attr.ValueState
}

func (v UnderlayProtocolValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ospf"] = basetypes.ObjectType{
		AttrTypes: OspfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Bfd1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Bgp1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.Ospf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospf"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UnderlayProtocolValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UnderlayProtocolValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UnderlayProtocolValue) String() string {
	return "UnderlayProtocolValue"
}

func (v UnderlayProtocolValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd1 basetypes.ObjectValue

	if v.Bfd1.IsNull() {
		bfd1 = types.ObjectNull(
			Bfd1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd1.IsUnknown() {
		bfd1 = types.ObjectUnknown(
			Bfd1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd1.IsNull() && !v.Bfd1.IsUnknown() {
		bfd1 = types.ObjectValueMust(
			Bfd1Value{}.AttributeTypes(ctx),
			v.Bfd1.Attributes(),
		)
	}

	var bgp1 basetypes.ObjectValue

	if v.Bgp1.IsNull() {
		bgp1 = types.ObjectNull(
			Bgp1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp1.IsUnknown() {
		bgp1 = types.ObjectUnknown(
			Bgp1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp1.IsNull() && !v.Bgp1.IsUnknown() {
		bgp1 = types.ObjectValueMust(
			Bgp1Value{}.AttributeTypes(ctx),
			v.Bgp1.Attributes(),
		)
	}

	var ospf basetypes.ObjectValue

	if v.Ospf.IsNull() {
		ospf = types.ObjectNull(
			OspfValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ospf.IsUnknown() {
		ospf = types.ObjectUnknown(
			OspfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ospf.IsNull() && !v.Ospf.IsUnknown() {
		ospf = types.ObjectValueMust(
			OspfValue{}.AttributeTypes(ctx),
			v.Ospf.Attributes(),
		)
	}

	var protocolVal basetypes.ListValue
	switch {
	case v.Protocol.IsUnknown():
		protocolVal = types.ListUnknown(types.StringType)
	case v.Protocol.IsNull():
		protocolVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		protocolVal, d = types.ListValue(types.StringType, v.Protocol.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bfd": basetypes.ObjectType{
				AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
			},
			"bgp": basetypes.ObjectType{
				AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
			},
			"ospf": basetypes.ObjectType{
				AttrTypes: OspfValue{}.AttributeTypes(ctx),
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
		},
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
		},
		"ospf": basetypes.ObjectType{
			AttrTypes: OspfValue{}.AttributeTypes(ctx),
		},
		"protocol": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd":      bfd1,
			"bgp":      bgp1,
			"ospf":     ospf,
			"protocol": protocolVal,
		})

	return objVal, diags
}

func (v UnderlayProtocolValue) Equal(o attr.Value) bool {
	other, ok := o.(UnderlayProtocolValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bfd1.Equal(other.Bfd1) {
		return false
	}

	if !v.Bgp1.Equal(other.Bgp1) {
		return false
	}

	if !v.Ospf.Equal(other.Ospf) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	return true
}

func (v UnderlayProtocolValue) Type(ctx context.Context) attr.Type {
	return UnderlayProtocolType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UnderlayProtocolValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
		},
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
		},
		"ospf": basetypes.ObjectType{
			AttrTypes: OspfValue{}.AttributeTypes(ctx),
		},
		"protocol": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Bfd1Type{}

type Bfd1Type struct {
	basetypes.ObjectType
}

func (t Bfd1Type) Equal(o attr.Type) bool {
	other, ok := o.(Bfd1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bfd1Type) String() string {
	return "Bfd1Type"
}

func (t Bfd1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return nil, diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return nil, diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return nil, diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return nil, diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return nil, diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bfd1Value{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfd1ValueNull() Bfd1Value {
	return Bfd1Value{
		state: attr.ValueStateNull,
	}
}

func NewBfd1ValueUnknown() Bfd1Value {
	return Bfd1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBfd1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bfd1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bfd1Value Attribute Value",
				"While creating a Bfd1Value value, a missing attribute value was detected. "+
					"A Bfd1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bfd1Value Attribute Type",
				"While creating a Bfd1Value value, an invalid attribute value was detected. "+
					"A Bfd1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bfd1Value Attribute Value",
				"While creating a Bfd1Value value, an extra attribute value was detected. "+
					"A Bfd1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bfd1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfd1ValueUnknown(), diags
	}

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return NewBfd1ValueUnknown(), diags
	}

	return Bfd1Value{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfd1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bfd1Value {
	object, diags := NewBfd1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfd1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bfd1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfd1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfd1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfd1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfd1ValueMust(Bfd1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bfd1Type) ValueType(ctx context.Context) attr.Value {
	return Bfd1Value{}
}

var _ basetypes.ObjectValuable = Bfd1Value{}

type Bfd1Value struct {
	DesiredMinTransmitInt  basetypes.Int64Value `tfsdk:"desired_min_transmit_int"`
	DetectionMultiplier    basetypes.Int64Value `tfsdk:"detection_multiplier"`
	Enabled                basetypes.BoolValue  `tfsdk:"enabled"`
	MinEchoReceiveInterval basetypes.Int64Value `tfsdk:"min_echo_receive_interval"`
	RequiredMinReceive     basetypes.Int64Value `tfsdk:"required_min_receive"`
	Ttl                    basetypes.Int64Value `tfsdk:"ttl"`
	state                  attr.ValueState
}

func (v Bfd1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["desired_min_transmit_int"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["detection_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_echo_receive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required_min_receive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ttl"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DesiredMinTransmitInt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_min_transmit_int"] = val

		val, err = v.DetectionMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detection_multiplier"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MinEchoReceiveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_echo_receive_interval"] = val

		val, err = v.RequiredMinReceive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_min_receive"] = val

		val, err = v.Ttl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ttl"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bfd1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bfd1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bfd1Value) String() string {
	return "Bfd1Value"
}

func (v Bfd1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"desired_min_transmit_int":  v.DesiredMinTransmitInt,
			"detection_multiplier":      v.DetectionMultiplier,
			"enabled":                   v.Enabled,
			"min_echo_receive_interval": v.MinEchoReceiveInterval,
			"required_min_receive":      v.RequiredMinReceive,
			"ttl":                       v.Ttl,
		})

	return objVal, diags
}

func (v Bfd1Value) Equal(o attr.Value) bool {
	other, ok := o.(Bfd1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DesiredMinTransmitInt.Equal(other.DesiredMinTransmitInt) {
		return false
	}

	if !v.DetectionMultiplier.Equal(other.DetectionMultiplier) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MinEchoReceiveInterval.Equal(other.MinEchoReceiveInterval) {
		return false
	}

	if !v.RequiredMinReceive.Equal(other.RequiredMinReceive) {
		return false
	}

	if !v.Ttl.Equal(other.Ttl) {
		return false
	}

	return true
}

func (v Bfd1Value) Type(ctx context.Context) attr.Type {
	return Bfd1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bfd1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Bgp1Type{}

type Bgp1Type struct {
	basetypes.ObjectType
}

func (t Bgp1Type) Equal(o attr.Type) bool {
	other, ok := o.(Bgp1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bgp1Type) String() string {
	return "Bgp1Type"
}

func (t Bgp1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return nil, diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	timers1Attribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers_1 is missing from object`)

		return nil, diags
	}

	timers1Val, ok := timers1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers_1 expected to be basetypes.ObjectValue, was: %T`, timers1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bgp1Value{
		AsnPool:      asnPoolVal,
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		Keychain:     keychainVal,
		Timers1:      timers1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewBgp1ValueNull() Bgp1Value {
	return Bgp1Value{
		state: attr.ValueStateNull,
	}
}

func NewBgp1ValueUnknown() Bgp1Value {
	return Bgp1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBgp1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bgp1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bgp1Value Attribute Value",
				"While creating a Bgp1Value value, a missing attribute value was detected. "+
					"A Bgp1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bgp1Value Attribute Type",
				"While creating a Bgp1Value value, an invalid attribute value was detected. "+
					"A Bgp1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bgp1Value Attribute Value",
				"While creating a Bgp1Value value, an extra attribute value was detected. "+
					"A Bgp1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bgp1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgp1ValueUnknown(), diags
	}

	asnPoolAttribute, ok := attributes["asn_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn_pool is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	asnPoolVal, ok := asnPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn_pool expected to be basetypes.StringValue, was: %T`, asnPoolAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	timers1Attribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers_1 is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	timers1Val, ok := timers1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers_1 expected to be basetypes.ObjectValue, was: %T`, timers1Attribute))
	}

	if diags.HasError() {
		return NewBgp1ValueUnknown(), diags
	}

	return Bgp1Value{
		AsnPool:      asnPoolVal,
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		Keychain:     keychainVal,
		Timers1:      timers1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewBgp1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bgp1Value {
	object, diags := NewBgp1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgp1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bgp1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgp1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgp1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgp1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgp1ValueMust(Bgp1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bgp1Type) ValueType(ctx context.Context) attr.Value {
	return Bgp1Value{}
}

var _ basetypes.ObjectValuable = Bgp1Value{}

type Bgp1Value struct {
	AsnPool      basetypes.StringValue `tfsdk:"asn_pool"`
	ExportPolicy basetypes.ListValue   `tfsdk:"export_policy"`
	ImportPolicy basetypes.ListValue   `tfsdk:"import_policy"`
	Keychain     basetypes.StringValue `tfsdk:"keychain"`
	Timers1      basetypes.ObjectValue `tfsdk:"timers"`
	state        attr.ValueState
}

func (v Bgp1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timers"] = basetypes.ObjectType{
		AttrTypes: Timers1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AsnPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn_pool"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.Timers1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bgp1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bgp1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bgp1Value) String() string {
	return "Bgp1Value"
}

func (v Bgp1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var timers1 basetypes.ObjectValue

	if v.Timers1.IsNull() {
		timers1 = types.ObjectNull(
			Timers1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Timers1.IsUnknown() {
		timers1 = types.ObjectUnknown(
			Timers1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Timers1.IsNull() && !v.Timers1.IsUnknown() {
		timers1 = types.ObjectValueMust(
			Timers1Value{}.AttributeTypes(ctx),
			v.Timers1.Attributes(),
		)
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain": basetypes.StringType{},
			"timers": basetypes.ObjectType{
				AttrTypes: Timers1Value{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"asn_pool": basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain": basetypes.StringType{},
			"timers": basetypes.ObjectType{
				AttrTypes: Timers1Value{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"keychain": basetypes.StringType{},
		"timers": basetypes.ObjectType{
			AttrTypes: Timers1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn_pool":      v.AsnPool,
			"export_policy": exportPolicyVal,
			"import_policy": importPolicyVal,
			"keychain":      v.Keychain,
			"timers":        timers1,
		})

	return objVal, diags
}

func (v Bgp1Value) Equal(o attr.Value) bool {
	other, ok := o.(Bgp1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsnPool.Equal(other.AsnPool) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.Timers1.Equal(other.Timers1) {
		return false
	}

	return true
}

func (v Bgp1Value) Type(ctx context.Context) attr.Type {
	return Bgp1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bgp1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn_pool": basetypes.StringType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"keychain": basetypes.StringType{},
		"timers": basetypes.ObjectType{
			AttrTypes: Timers1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Timers1Type{}

type Timers1Type struct {
	basetypes.ObjectType
}

func (t Timers1Type) Equal(o attr.Type) bool {
	other, ok := o.(Timers1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Timers1Type) String() string {
	return "Timers1Type"
}

func (t Timers1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return nil, diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return nil, diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return nil, diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Timers1Value{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimers1ValueNull() Timers1Value {
	return Timers1Value{
		state: attr.ValueStateNull,
	}
}

func NewTimers1ValueUnknown() Timers1Value {
	return Timers1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTimers1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Timers1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Timers1Value Attribute Value",
				"While creating a Timers1Value value, a missing attribute value was detected. "+
					"A Timers1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Timers1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Timers1Value Attribute Type",
				"While creating a Timers1Value value, an invalid attribute value was detected. "+
					"A Timers1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Timers1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Timers1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Timers1Value Attribute Value",
				"While creating a Timers1Value value, an extra attribute value was detected. "+
					"A Timers1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Timers1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimers1ValueUnknown(), diags
	}

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return NewTimers1ValueUnknown(), diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewTimers1ValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return NewTimers1ValueUnknown(), diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return NewTimers1ValueUnknown(), diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return NewTimers1ValueUnknown(), diags
	}

	return Timers1Value{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimers1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Timers1Value {
	object, diags := NewTimers1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimers1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Timers1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimers1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimers1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimers1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimers1ValueMust(Timers1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Timers1Type) ValueType(ctx context.Context) attr.Value {
	return Timers1Value{}
}

var _ basetypes.ObjectValuable = Timers1Value{}

type Timers1Value struct {
	ConnectRetry                 basetypes.Int64Value `tfsdk:"connect_retry"`
	HoldTime                     basetypes.Int64Value `tfsdk:"hold_time"`
	KeepAlive                    basetypes.Int64Value `tfsdk:"keep_alive"`
	MinimumAdvertisementInterval basetypes.Int64Value `tfsdk:"minimum_advertisement_interval"`
	state                        attr.ValueState
}

func (v Timers1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["connect_retry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_alive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimum_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConnectRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connect_retry"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.KeepAlive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_alive"] = val

		val, err = v.MinimumAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_advertisement_interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Timers1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Timers1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Timers1Value) String() string {
	return "Timers1Value"
}

func (v Timers1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connect_retry":                  v.ConnectRetry,
			"hold_time":                      v.HoldTime,
			"keep_alive":                     v.KeepAlive,
			"minimum_advertisement_interval": v.MinimumAdvertisementInterval,
		})

	return objVal, diags
}

func (v Timers1Value) Equal(o attr.Value) bool {
	other, ok := o.(Timers1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectRetry.Equal(other.ConnectRetry) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.KeepAlive.Equal(other.KeepAlive) {
		return false
	}

	if !v.MinimumAdvertisementInterval.Equal(other.MinimumAdvertisementInterval) {
		return false
	}

	return true
}

func (v Timers1Value) Type(ctx context.Context) attr.Type {
	return Timers1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Timers1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = OspfType{}

type OspfType struct {
	basetypes.ObjectType
}

func (t OspfType) Equal(o attr.Type) bool {
	other, ok := o.(OspfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfType) String() string {
	return "OspfType"
}

func (t OspfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return nil, diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfValue{
		AddressFamily: addressFamilyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewOspfValueNull() OspfValue {
	return OspfValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfValueUnknown() OspfValue {
	return OspfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfValue Attribute Value",
				"While creating a OspfValue value, a missing attribute value was detected. "+
					"A OspfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfValue Attribute Type",
				"While creating a OspfValue value, an invalid attribute value was detected. "+
					"A OspfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfValue Attribute Value",
				"While creating a OspfValue value, an extra attribute value was detected. "+
					"A OspfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfValueUnknown(), diags
	}

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return NewOspfValueUnknown(), diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	if diags.HasError() {
		return NewOspfValueUnknown(), diags
	}

	return OspfValue{
		AddressFamily: addressFamilyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewOspfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfValue {
	object, diags := NewOspfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfValueMust(OspfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfType) ValueType(ctx context.Context) attr.Value {
	return OspfValue{}
}

var _ basetypes.ObjectValuable = OspfValue{}

type OspfValue struct {
	AddressFamily basetypes.ListValue `tfsdk:"address_family"`
	state         attr.ValueState
}

func (v OspfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["address_family"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.AddressFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_family"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfValue) String() string {
	return "OspfValue"
}

func (v OspfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addressFamilyVal basetypes.ListValue
	switch {
	case v.AddressFamily.IsUnknown():
		addressFamilyVal = types.ListUnknown(types.StringType)
	case v.AddressFamily.IsNull():
		addressFamilyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addressFamilyVal, d = types.ListValue(types.StringType, v.AddressFamily.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_family": addressFamilyVal,
		})

	return objVal, diags
}

func (v OspfValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressFamily.Equal(other.AddressFamily) {
		return false
	}

	return true
}

func (v OspfValue) Type(ctx context.Context) attr.Type {
	return OspfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	borderLeafNodesAttribute, ok := attributes["border_leaf_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`border_leaf_nodes is missing from object`)

		return nil, diags
	}

	borderLeafNodesVal, ok := borderLeafNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`border_leaf_nodes expected to be basetypes.ListValue, was: %T`, borderLeafNodesAttribute))
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	leafNodesAttribute, ok := attributes["leaf_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leaf_nodes is missing from object`)

		return nil, diags
	}

	leafNodesVal, ok := leafNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leaf_nodes expected to be basetypes.ListValue, was: %T`, leafNodesAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	spineNodesAttribute, ok := attributes["spine_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spine_nodes is missing from object`)

		return nil, diags
	}

	spineNodesVal, ok := spineNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spine_nodes expected to be basetypes.ListValue, was: %T`, spineNodesAttribute))
	}

	superSpineNodesAttribute, ok := attributes["super_spine_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`super_spine_nodes is missing from object`)

		return nil, diags
	}

	superSpineNodesVal, ok := superSpineNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`super_spine_nodes expected to be basetypes.ListValue, was: %T`, superSpineNodesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		BorderLeafNodes:   borderLeafNodesVal,
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		LeafNodes:         leafNodesVal,
		OperationalState:  operationalStateVal,
		SpineNodes:        spineNodesVal,
		SuperSpineNodes:   superSpineNodesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	borderLeafNodesAttribute, ok := attributes["border_leaf_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`border_leaf_nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	borderLeafNodesVal, ok := borderLeafNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`border_leaf_nodes expected to be basetypes.ListValue, was: %T`, borderLeafNodesAttribute))
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	leafNodesAttribute, ok := attributes["leaf_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leaf_nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	leafNodesVal, ok := leafNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leaf_nodes expected to be basetypes.ListValue, was: %T`, leafNodesAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	spineNodesAttribute, ok := attributes["spine_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spine_nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	spineNodesVal, ok := spineNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spine_nodes expected to be basetypes.ListValue, was: %T`, spineNodesAttribute))
	}

	superSpineNodesAttribute, ok := attributes["super_spine_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`super_spine_nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	superSpineNodesVal, ok := superSpineNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`super_spine_nodes expected to be basetypes.ListValue, was: %T`, superSpineNodesAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		BorderLeafNodes:   borderLeafNodesVal,
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		LeafNodes:         leafNodesVal,
		OperationalState:  operationalStateVal,
		SpineNodes:        spineNodesVal,
		SuperSpineNodes:   superSpineNodesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	BorderLeafNodes   basetypes.ListValue   `tfsdk:"border_leaf_nodes"`
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	LeafNodes         basetypes.ListValue   `tfsdk:"leaf_nodes"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	SpineNodes        basetypes.ListValue   `tfsdk:"spine_nodes"`
	SuperSpineNodes   basetypes.ListValue   `tfsdk:"super_spine_nodes"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["border_leaf_nodes"] = basetypes.ListType{
		ElemType: BorderLeafNodesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["leaf_nodes"] = basetypes.ListType{
		ElemType: LeafNodesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spine_nodes"] = basetypes.ListType{
		ElemType: SpineNodesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["super_spine_nodes"] = basetypes.ListType{
		ElemType: SuperSpineNodesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.BorderLeafNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["border_leaf_nodes"] = val

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.LeafNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["leaf_nodes"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.SpineNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spine_nodes"] = val

		val, err = v.SuperSpineNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["super_spine_nodes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	borderLeafNodes := types.ListValueMust(
		BorderLeafNodesType{
			basetypes.ObjectType{
				AttrTypes: BorderLeafNodesValue{}.AttributeTypes(ctx),
			},
		},
		v.BorderLeafNodes.Elements(),
	)

	if v.BorderLeafNodes.IsNull() {
		borderLeafNodes = types.ListNull(
			BorderLeafNodesType{
				basetypes.ObjectType{
					AttrTypes: BorderLeafNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BorderLeafNodes.IsUnknown() {
		borderLeafNodes = types.ListUnknown(
			BorderLeafNodesType{
				basetypes.ObjectType{
					AttrTypes: BorderLeafNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	leafNodes := types.ListValueMust(
		LeafNodesType{
			basetypes.ObjectType{
				AttrTypes: LeafNodesValue{}.AttributeTypes(ctx),
			},
		},
		v.LeafNodes.Elements(),
	)

	if v.LeafNodes.IsNull() {
		leafNodes = types.ListNull(
			LeafNodesType{
				basetypes.ObjectType{
					AttrTypes: LeafNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.LeafNodes.IsUnknown() {
		leafNodes = types.ListUnknown(
			LeafNodesType{
				basetypes.ObjectType{
					AttrTypes: LeafNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	spineNodes := types.ListValueMust(
		SpineNodesType{
			basetypes.ObjectType{
				AttrTypes: SpineNodesValue{}.AttributeTypes(ctx),
			},
		},
		v.SpineNodes.Elements(),
	)

	if v.SpineNodes.IsNull() {
		spineNodes = types.ListNull(
			SpineNodesType{
				basetypes.ObjectType{
					AttrTypes: SpineNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SpineNodes.IsUnknown() {
		spineNodes = types.ListUnknown(
			SpineNodesType{
				basetypes.ObjectType{
					AttrTypes: SpineNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	superSpineNodes := types.ListValueMust(
		SuperSpineNodesType{
			basetypes.ObjectType{
				AttrTypes: SuperSpineNodesValue{}.AttributeTypes(ctx),
			},
		},
		v.SuperSpineNodes.Elements(),
	)

	if v.SuperSpineNodes.IsNull() {
		superSpineNodes = types.ListNull(
			SuperSpineNodesType{
				basetypes.ObjectType{
					AttrTypes: SuperSpineNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SuperSpineNodes.IsUnknown() {
		superSpineNodes = types.ListUnknown(
			SuperSpineNodesType{
				basetypes.ObjectType{
					AttrTypes: SuperSpineNodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"border_leaf_nodes": basetypes.ListType{
			ElemType: BorderLeafNodesValue{}.Type(ctx),
		},
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"leaf_nodes": basetypes.ListType{
			ElemType: LeafNodesValue{}.Type(ctx),
		},
		"operational_state": basetypes.StringType{},
		"spine_nodes": basetypes.ListType{
			ElemType: SpineNodesValue{}.Type(ctx),
		},
		"super_spine_nodes": basetypes.ListType{
			ElemType: SuperSpineNodesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"border_leaf_nodes":   borderLeafNodes,
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"last_change":         v.LastChange,
			"leaf_nodes":          leafNodes,
			"operational_state":   v.OperationalState,
			"spine_nodes":         spineNodes,
			"super_spine_nodes":   superSpineNodes,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BorderLeafNodes.Equal(other.BorderLeafNodes) {
		return false
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.LeafNodes.Equal(other.LeafNodes) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.SpineNodes.Equal(other.SpineNodes) {
		return false
	}

	if !v.SuperSpineNodes.Equal(other.SuperSpineNodes) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"border_leaf_nodes": basetypes.ListType{
			ElemType: BorderLeafNodesValue{}.Type(ctx),
		},
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"leaf_nodes": basetypes.ListType{
			ElemType: LeafNodesValue{}.Type(ctx),
		},
		"operational_state": basetypes.StringType{},
		"spine_nodes": basetypes.ListType{
			ElemType: SpineNodesValue{}.Type(ctx),
		},
		"super_spine_nodes": basetypes.ListType{
			ElemType: SuperSpineNodesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BorderLeafNodesType{}

type BorderLeafNodesType struct {
	basetypes.ObjectType
}

func (t BorderLeafNodesType) Equal(o attr.Type) bool {
	other, ok := o.(BorderLeafNodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BorderLeafNodesType) String() string {
	return "BorderLeafNodesType"
}

func (t BorderLeafNodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return nil, diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	underlayAutonomousSystemAttribute, ok := attributes["underlay_autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_autonomous_system is missing from object`)

		return nil, diags
	}

	underlayAutonomousSystemVal, ok := underlayAutonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_autonomous_system expected to be basetypes.Int64Value, was: %T`, underlayAutonomousSystemAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BorderLeafNodesValue{
		Node:                     nodeVal,
		OperatingSystem:          operatingSystemVal,
		OperatingSystemVersion:   operatingSystemVersionVal,
		UnderlayAutonomousSystem: underlayAutonomousSystemVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewBorderLeafNodesValueNull() BorderLeafNodesValue {
	return BorderLeafNodesValue{
		state: attr.ValueStateNull,
	}
}

func NewBorderLeafNodesValueUnknown() BorderLeafNodesValue {
	return BorderLeafNodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBorderLeafNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BorderLeafNodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BorderLeafNodesValue Attribute Value",
				"While creating a BorderLeafNodesValue value, a missing attribute value was detected. "+
					"A BorderLeafNodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BorderLeafNodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BorderLeafNodesValue Attribute Type",
				"While creating a BorderLeafNodesValue value, an invalid attribute value was detected. "+
					"A BorderLeafNodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BorderLeafNodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BorderLeafNodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BorderLeafNodesValue Attribute Value",
				"While creating a BorderLeafNodesValue value, an extra attribute value was detected. "+
					"A BorderLeafNodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BorderLeafNodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBorderLeafNodesValueUnknown(), diags
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewBorderLeafNodesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewBorderLeafNodesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return NewBorderLeafNodesValueUnknown(), diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	underlayAutonomousSystemAttribute, ok := attributes["underlay_autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_autonomous_system is missing from object`)

		return NewBorderLeafNodesValueUnknown(), diags
	}

	underlayAutonomousSystemVal, ok := underlayAutonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_autonomous_system expected to be basetypes.Int64Value, was: %T`, underlayAutonomousSystemAttribute))
	}

	if diags.HasError() {
		return NewBorderLeafNodesValueUnknown(), diags
	}

	return BorderLeafNodesValue{
		Node:                     nodeVal,
		OperatingSystem:          operatingSystemVal,
		OperatingSystemVersion:   operatingSystemVersionVal,
		UnderlayAutonomousSystem: underlayAutonomousSystemVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewBorderLeafNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BorderLeafNodesValue {
	object, diags := NewBorderLeafNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBorderLeafNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BorderLeafNodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBorderLeafNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBorderLeafNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBorderLeafNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBorderLeafNodesValueMust(BorderLeafNodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BorderLeafNodesType) ValueType(ctx context.Context) attr.Value {
	return BorderLeafNodesValue{}
}

var _ basetypes.ObjectValuable = BorderLeafNodesValue{}

type BorderLeafNodesValue struct {
	Node                     basetypes.StringValue `tfsdk:"node"`
	OperatingSystem          basetypes.StringValue `tfsdk:"operating_system"`
	OperatingSystemVersion   basetypes.StringValue `tfsdk:"operating_system_version"`
	UnderlayAutonomousSystem basetypes.Int64Value  `tfsdk:"underlay_autonomous_system"`
	state                    attr.ValueState
}

func (v BorderLeafNodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["underlay_autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperatingSystemVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system_version"] = val

		val, err = v.UnderlayAutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["underlay_autonomous_system"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BorderLeafNodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BorderLeafNodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BorderLeafNodesValue) String() string {
	return "BorderLeafNodesValue"
}

func (v BorderLeafNodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"node":                       basetypes.StringType{},
		"operating_system":           basetypes.StringType{},
		"operating_system_version":   basetypes.StringType{},
		"underlay_autonomous_system": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node":                       v.Node,
			"operating_system":           v.OperatingSystem,
			"operating_system_version":   v.OperatingSystemVersion,
			"underlay_autonomous_system": v.UnderlayAutonomousSystem,
		})

	return objVal, diags
}

func (v BorderLeafNodesValue) Equal(o attr.Value) bool {
	other, ok := o.(BorderLeafNodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperatingSystemVersion.Equal(other.OperatingSystemVersion) {
		return false
	}

	if !v.UnderlayAutonomousSystem.Equal(other.UnderlayAutonomousSystem) {
		return false
	}

	return true
}

func (v BorderLeafNodesValue) Type(ctx context.Context) attr.Type {
	return BorderLeafNodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BorderLeafNodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node":                       basetypes.StringType{},
		"operating_system":           basetypes.StringType{},
		"operating_system_version":   basetypes.StringType{},
		"underlay_autonomous_system": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LeafNodesType{}

type LeafNodesType struct {
	basetypes.ObjectType
}

func (t LeafNodesType) Equal(o attr.Type) bool {
	other, ok := o.(LeafNodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LeafNodesType) String() string {
	return "LeafNodesType"
}

func (t LeafNodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return nil, diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	underlayAutonomousSystemAttribute, ok := attributes["underlay_autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_autonomous_system is missing from object`)

		return nil, diags
	}

	underlayAutonomousSystemVal, ok := underlayAutonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_autonomous_system expected to be basetypes.Int64Value, was: %T`, underlayAutonomousSystemAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LeafNodesValue{
		Node:                     nodeVal,
		OperatingSystem:          operatingSystemVal,
		OperatingSystemVersion:   operatingSystemVersionVal,
		UnderlayAutonomousSystem: underlayAutonomousSystemVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewLeafNodesValueNull() LeafNodesValue {
	return LeafNodesValue{
		state: attr.ValueStateNull,
	}
}

func NewLeafNodesValueUnknown() LeafNodesValue {
	return LeafNodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLeafNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LeafNodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LeafNodesValue Attribute Value",
				"While creating a LeafNodesValue value, a missing attribute value was detected. "+
					"A LeafNodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LeafNodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LeafNodesValue Attribute Type",
				"While creating a LeafNodesValue value, an invalid attribute value was detected. "+
					"A LeafNodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LeafNodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LeafNodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LeafNodesValue Attribute Value",
				"While creating a LeafNodesValue value, an extra attribute value was detected. "+
					"A LeafNodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LeafNodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLeafNodesValueUnknown(), diags
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewLeafNodesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewLeafNodesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return NewLeafNodesValueUnknown(), diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	underlayAutonomousSystemAttribute, ok := attributes["underlay_autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_autonomous_system is missing from object`)

		return NewLeafNodesValueUnknown(), diags
	}

	underlayAutonomousSystemVal, ok := underlayAutonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_autonomous_system expected to be basetypes.Int64Value, was: %T`, underlayAutonomousSystemAttribute))
	}

	if diags.HasError() {
		return NewLeafNodesValueUnknown(), diags
	}

	return LeafNodesValue{
		Node:                     nodeVal,
		OperatingSystem:          operatingSystemVal,
		OperatingSystemVersion:   operatingSystemVersionVal,
		UnderlayAutonomousSystem: underlayAutonomousSystemVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewLeafNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LeafNodesValue {
	object, diags := NewLeafNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLeafNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LeafNodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLeafNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLeafNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLeafNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLeafNodesValueMust(LeafNodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LeafNodesType) ValueType(ctx context.Context) attr.Value {
	return LeafNodesValue{}
}

var _ basetypes.ObjectValuable = LeafNodesValue{}

type LeafNodesValue struct {
	Node                     basetypes.StringValue `tfsdk:"node"`
	OperatingSystem          basetypes.StringValue `tfsdk:"operating_system"`
	OperatingSystemVersion   basetypes.StringValue `tfsdk:"operating_system_version"`
	UnderlayAutonomousSystem basetypes.Int64Value  `tfsdk:"underlay_autonomous_system"`
	state                    attr.ValueState
}

func (v LeafNodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["underlay_autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperatingSystemVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system_version"] = val

		val, err = v.UnderlayAutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["underlay_autonomous_system"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LeafNodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LeafNodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LeafNodesValue) String() string {
	return "LeafNodesValue"
}

func (v LeafNodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"node":                       basetypes.StringType{},
		"operating_system":           basetypes.StringType{},
		"operating_system_version":   basetypes.StringType{},
		"underlay_autonomous_system": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node":                       v.Node,
			"operating_system":           v.OperatingSystem,
			"operating_system_version":   v.OperatingSystemVersion,
			"underlay_autonomous_system": v.UnderlayAutonomousSystem,
		})

	return objVal, diags
}

func (v LeafNodesValue) Equal(o attr.Value) bool {
	other, ok := o.(LeafNodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperatingSystemVersion.Equal(other.OperatingSystemVersion) {
		return false
	}

	if !v.UnderlayAutonomousSystem.Equal(other.UnderlayAutonomousSystem) {
		return false
	}

	return true
}

func (v LeafNodesValue) Type(ctx context.Context) attr.Type {
	return LeafNodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LeafNodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node":                       basetypes.StringType{},
		"operating_system":           basetypes.StringType{},
		"operating_system_version":   basetypes.StringType{},
		"underlay_autonomous_system": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SpineNodesType{}

type SpineNodesType struct {
	basetypes.ObjectType
}

func (t SpineNodesType) Equal(o attr.Type) bool {
	other, ok := o.(SpineNodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpineNodesType) String() string {
	return "SpineNodesType"
}

func (t SpineNodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return nil, diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	underlayAutonomousSystemAttribute, ok := attributes["underlay_autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_autonomous_system is missing from object`)

		return nil, diags
	}

	underlayAutonomousSystemVal, ok := underlayAutonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_autonomous_system expected to be basetypes.Int64Value, was: %T`, underlayAutonomousSystemAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpineNodesValue{
		Node:                     nodeVal,
		OperatingSystem:          operatingSystemVal,
		OperatingSystemVersion:   operatingSystemVersionVal,
		UnderlayAutonomousSystem: underlayAutonomousSystemVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewSpineNodesValueNull() SpineNodesValue {
	return SpineNodesValue{
		state: attr.ValueStateNull,
	}
}

func NewSpineNodesValueUnknown() SpineNodesValue {
	return SpineNodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpineNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpineNodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpineNodesValue Attribute Value",
				"While creating a SpineNodesValue value, a missing attribute value was detected. "+
					"A SpineNodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpineNodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpineNodesValue Attribute Type",
				"While creating a SpineNodesValue value, an invalid attribute value was detected. "+
					"A SpineNodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpineNodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpineNodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpineNodesValue Attribute Value",
				"While creating a SpineNodesValue value, an extra attribute value was detected. "+
					"A SpineNodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpineNodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpineNodesValueUnknown(), diags
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewSpineNodesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewSpineNodesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return NewSpineNodesValueUnknown(), diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	underlayAutonomousSystemAttribute, ok := attributes["underlay_autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_autonomous_system is missing from object`)

		return NewSpineNodesValueUnknown(), diags
	}

	underlayAutonomousSystemVal, ok := underlayAutonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_autonomous_system expected to be basetypes.Int64Value, was: %T`, underlayAutonomousSystemAttribute))
	}

	if diags.HasError() {
		return NewSpineNodesValueUnknown(), diags
	}

	return SpineNodesValue{
		Node:                     nodeVal,
		OperatingSystem:          operatingSystemVal,
		OperatingSystemVersion:   operatingSystemVersionVal,
		UnderlayAutonomousSystem: underlayAutonomousSystemVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewSpineNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpineNodesValue {
	object, diags := NewSpineNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpineNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpineNodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpineNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpineNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpineNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpineNodesValueMust(SpineNodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpineNodesType) ValueType(ctx context.Context) attr.Value {
	return SpineNodesValue{}
}

var _ basetypes.ObjectValuable = SpineNodesValue{}

type SpineNodesValue struct {
	Node                     basetypes.StringValue `tfsdk:"node"`
	OperatingSystem          basetypes.StringValue `tfsdk:"operating_system"`
	OperatingSystemVersion   basetypes.StringValue `tfsdk:"operating_system_version"`
	UnderlayAutonomousSystem basetypes.Int64Value  `tfsdk:"underlay_autonomous_system"`
	state                    attr.ValueState
}

func (v SpineNodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["underlay_autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperatingSystemVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system_version"] = val

		val, err = v.UnderlayAutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["underlay_autonomous_system"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpineNodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpineNodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpineNodesValue) String() string {
	return "SpineNodesValue"
}

func (v SpineNodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"node":                       basetypes.StringType{},
		"operating_system":           basetypes.StringType{},
		"operating_system_version":   basetypes.StringType{},
		"underlay_autonomous_system": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node":                       v.Node,
			"operating_system":           v.OperatingSystem,
			"operating_system_version":   v.OperatingSystemVersion,
			"underlay_autonomous_system": v.UnderlayAutonomousSystem,
		})

	return objVal, diags
}

func (v SpineNodesValue) Equal(o attr.Value) bool {
	other, ok := o.(SpineNodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperatingSystemVersion.Equal(other.OperatingSystemVersion) {
		return false
	}

	if !v.UnderlayAutonomousSystem.Equal(other.UnderlayAutonomousSystem) {
		return false
	}

	return true
}

func (v SpineNodesValue) Type(ctx context.Context) attr.Type {
	return SpineNodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpineNodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node":                       basetypes.StringType{},
		"operating_system":           basetypes.StringType{},
		"operating_system_version":   basetypes.StringType{},
		"underlay_autonomous_system": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SuperSpineNodesType{}

type SuperSpineNodesType struct {
	basetypes.ObjectType
}

func (t SuperSpineNodesType) Equal(o attr.Type) bool {
	other, ok := o.(SuperSpineNodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SuperSpineNodesType) String() string {
	return "SuperSpineNodesType"
}

func (t SuperSpineNodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return nil, diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	underlayAutonomousSystemAttribute, ok := attributes["underlay_autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_autonomous_system is missing from object`)

		return nil, diags
	}

	underlayAutonomousSystemVal, ok := underlayAutonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_autonomous_system expected to be basetypes.Int64Value, was: %T`, underlayAutonomousSystemAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SuperSpineNodesValue{
		Node:                     nodeVal,
		OperatingSystem:          operatingSystemVal,
		OperatingSystemVersion:   operatingSystemVersionVal,
		UnderlayAutonomousSystem: underlayAutonomousSystemVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewSuperSpineNodesValueNull() SuperSpineNodesValue {
	return SuperSpineNodesValue{
		state: attr.ValueStateNull,
	}
}

func NewSuperSpineNodesValueUnknown() SuperSpineNodesValue {
	return SuperSpineNodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSuperSpineNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SuperSpineNodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SuperSpineNodesValue Attribute Value",
				"While creating a SuperSpineNodesValue value, a missing attribute value was detected. "+
					"A SuperSpineNodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SuperSpineNodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SuperSpineNodesValue Attribute Type",
				"While creating a SuperSpineNodesValue value, an invalid attribute value was detected. "+
					"A SuperSpineNodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SuperSpineNodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SuperSpineNodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SuperSpineNodesValue Attribute Value",
				"While creating a SuperSpineNodesValue value, an extra attribute value was detected. "+
					"A SuperSpineNodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SuperSpineNodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSuperSpineNodesValueUnknown(), diags
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewSuperSpineNodesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewSuperSpineNodesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operatingSystemVersionAttribute, ok := attributes["operating_system_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system_version is missing from object`)

		return NewSuperSpineNodesValueUnknown(), diags
	}

	operatingSystemVersionVal, ok := operatingSystemVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system_version expected to be basetypes.StringValue, was: %T`, operatingSystemVersionAttribute))
	}

	underlayAutonomousSystemAttribute, ok := attributes["underlay_autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay_autonomous_system is missing from object`)

		return NewSuperSpineNodesValueUnknown(), diags
	}

	underlayAutonomousSystemVal, ok := underlayAutonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay_autonomous_system expected to be basetypes.Int64Value, was: %T`, underlayAutonomousSystemAttribute))
	}

	if diags.HasError() {
		return NewSuperSpineNodesValueUnknown(), diags
	}

	return SuperSpineNodesValue{
		Node:                     nodeVal,
		OperatingSystem:          operatingSystemVal,
		OperatingSystemVersion:   operatingSystemVersionVal,
		UnderlayAutonomousSystem: underlayAutonomousSystemVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewSuperSpineNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SuperSpineNodesValue {
	object, diags := NewSuperSpineNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSuperSpineNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SuperSpineNodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSuperSpineNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSuperSpineNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSuperSpineNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSuperSpineNodesValueMust(SuperSpineNodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SuperSpineNodesType) ValueType(ctx context.Context) attr.Value {
	return SuperSpineNodesValue{}
}

var _ basetypes.ObjectValuable = SuperSpineNodesValue{}

type SuperSpineNodesValue struct {
	Node                     basetypes.StringValue `tfsdk:"node"`
	OperatingSystem          basetypes.StringValue `tfsdk:"operating_system"`
	OperatingSystemVersion   basetypes.StringValue `tfsdk:"operating_system_version"`
	UnderlayAutonomousSystem basetypes.Int64Value  `tfsdk:"underlay_autonomous_system"`
	state                    attr.ValueState
}

func (v SuperSpineNodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["underlay_autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperatingSystemVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system_version"] = val

		val, err = v.UnderlayAutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["underlay_autonomous_system"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SuperSpineNodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SuperSpineNodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SuperSpineNodesValue) String() string {
	return "SuperSpineNodesValue"
}

func (v SuperSpineNodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"node":                       basetypes.StringType{},
		"operating_system":           basetypes.StringType{},
		"operating_system_version":   basetypes.StringType{},
		"underlay_autonomous_system": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node":                       v.Node,
			"operating_system":           v.OperatingSystem,
			"operating_system_version":   v.OperatingSystemVersion,
			"underlay_autonomous_system": v.UnderlayAutonomousSystem,
		})

	return objVal, diags
}

func (v SuperSpineNodesValue) Equal(o attr.Value) bool {
	other, ok := o.(SuperSpineNodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperatingSystemVersion.Equal(other.OperatingSystemVersion) {
		return false
	}

	if !v.UnderlayAutonomousSystem.Equal(other.UnderlayAutonomousSystem) {
		return false
	}

	return true
}

func (v SuperSpineNodesValue) Type(ctx context.Context) attr.Type {
	return SuperSpineNodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SuperSpineNodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node":                       basetypes.StringType{},
		"operating_system":           basetypes.StringType{},
		"operating_system_version":   basetypes.StringType{},
		"underlay_autonomous_system": basetypes.Int64Type{},
	}
}
