// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_isl

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func IslDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"alarms": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"critical": schema.Int64Attribute{
						Computed: true,
					},
					"major": schema.Int64Attribute{
						Computed: true,
					},
					"minor": schema.Int64Attribute{
						Computed: true,
					},
					"warning": schema.Int64Attribute{
						Computed: true,
					},
				},
				CustomType: AlarmsType{
					ObjectType: types.ObjectType{
						AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"deviations": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"count": schema.Int64Attribute{
						Computed: true,
					},
				},
				CustomType: DeviationsType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"hash": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "resource content will be returned as it was at the time of this git hash",
				MarkdownDescription: "resource content will be returned as it was at the time of this git hash",
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "name of the ISL",
				MarkdownDescription: "name of the ISL",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bfd": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"desired_min_transmit_int": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval in microseconds between transmission of BFD control packets.",
								MarkdownDescription: "The minimum interval in microseconds between transmission of BFD control packets.",
							},
							"detection_multiplier": schema.Int64Attribute{
								Optional:            true,
								Description:         "The number of packets that must be missed to declare this session as down.",
								MarkdownDescription: "The number of packets that must be missed to declare this session as down.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable Biforward Detection.",
								MarkdownDescription: "Enable Biforward Detection.",
							},
							"min_echo_receive_interval": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval between echo packets the local node can receive in microseconds.",
								MarkdownDescription: "The minimum interval between echo packets the local node can receive in microseconds.",
							},
							"required_min_receive": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval in microseconds between received BFD control packets that this system should support.",
								MarkdownDescription: "The minimum interval in microseconds between received BFD control packets that this system should support.",
							},
							"ttl": schema.Int64Attribute{
								Optional:            true,
								Description:         "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
								MarkdownDescription: "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
							},
						},
						CustomType: BfdType{
							ObjectType: types.ObjectType{
								AttrTypes: BfdValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Enable or disable BFD on the ISL. [default=false]",
						MarkdownDescription: "Enable or disable BFD on the ISL. [default=false]",
					},
					"bgp": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"afi_safi": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Which AFI and SAFI to advertise on the BGP peering session. Options: ipv4unicast, ipv6unicast, l2vpnevpn",
								MarkdownDescription: "Which AFI and SAFI to advertise on the BGP peering session. Options: ipv4unicast, ipv6unicast, l2vpnevpn",
							},
							"bgp_group": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to a DefaultBgpGroup.",
								MarkdownDescription: "Reference to a DefaultBgpGroup.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable or disable BGP peering between the two endpoints of the ISL. [default=false]",
								MarkdownDescription: "Enable or disable BGP peering between the two endpoints of the ISL. [default=false]",
							},
							"export_policy": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Reference to a RoutingPolicy to use when evaluating route exports from the DefaultRouter.",
								MarkdownDescription: "Reference to a RoutingPolicy to use when evaluating route exports from the DefaultRouter.",
							},
							"import_policy": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Reference to a RoutingPolicy to use when evaluating route imports into the DefaultRouter.",
								MarkdownDescription: "Reference to a RoutingPolicy to use when evaluating route imports into the DefaultRouter.",
							},
							"keychain": schema.StringAttribute{
								Optional:            true,
								Description:         "Keychain to be used for authentication",
								MarkdownDescription: "Keychain to be used for authentication",
							},
							"local_interface_as": schema.Int64Attribute{
								Optional:            true,
								Description:         "The Autonomous System to configure on the Local Interface.",
								MarkdownDescription: "The Autonomous System to configure on the Local Interface.",
							},
							"remote_interface_as": schema.Int64Attribute{
								Optional:            true,
								Description:         "The Autonomous System to configure on the Remote Interface.",
								MarkdownDescription: "The Autonomous System to configure on the Remote Interface.",
							},
						},
						CustomType: BgpType{
							ObjectType: types.ObjectType{
								AttrTypes: BgpValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"ip_mtu": schema.Int64Attribute{
						Optional:            true,
						Description:         "Sets the IP MTU for the local and remote Interfaces",
						MarkdownDescription: "Sets the IP MTU for the local and remote Interfaces",
					},
					"local_default_router": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to the DefautlRouter associated with the local Interface in which the ISL will be provisioned.",
						MarkdownDescription: "Reference to the DefautlRouter associated with the local Interface in which the ISL will be provisioned.",
					},
					"local_interface": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an Interface.",
						MarkdownDescription: "Reference to an Interface.",
					},
					"ospf": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable or disable OSPF between the two endpoints of the ISL.\nkubebuilder:validation:Boolean",
								MarkdownDescription: "Enable or disable OSPF between the two endpoints of the ISL.\nkubebuilder:validation:Boolean",
							},
							"ospfv2": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"local_ipv4_area": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV4 DefaultOSPFArea on the local interface.",
										MarkdownDescription: "Reference to a IPV4 DefaultOSPFArea on the local interface.",
									},
									"local_ipv4_instance": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV4 DefaultOSPFInstance on the local interface.",
										MarkdownDescription: "Reference to a IPV4 DefaultOSPFInstance on the local interface.",
									},
									"remote_ipv4_area": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV4 DefaultOSPFArea on the remote interface.",
										MarkdownDescription: "Reference to a IPV4 DefaultOSPFArea on the remote interface.",
									},
									"remote_ipv4_instance": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV4 DefaultOSPFInstance on the remote interface",
										MarkdownDescription: "Reference to a IPV4 DefaultOSPFInstance on the remote interface",
									},
								},
								CustomType: Ospfv2Type{
									ObjectType: types.ObjectType{
										AttrTypes: Ospfv2Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "OSPFv2 Parameters.",
								MarkdownDescription: "OSPFv2 Parameters.",
							},
							"ospfv3": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"local_ipv4_area": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV4 DefaultOSPFArea on the local interface.",
										MarkdownDescription: "Reference to a IPV4 DefaultOSPFArea on the local interface.",
									},
									"local_ipv4_instance": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV4 DefaultOSPFInstance on the local interface",
										MarkdownDescription: "Reference to a IPV4 DefaultOSPFInstance on the local interface",
									},
									"local_ipv6_area": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV6 DefaultOSPFArea on the local interface.",
										MarkdownDescription: "Reference to a IPV6 DefaultOSPFArea on the local interface.",
									},
									"local_ipv6_instance": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV6 DefaultOSPFInstance on the local interface.",
										MarkdownDescription: "Reference to a IPV6 DefaultOSPFInstance on the local interface.",
									},
									"remote_ipv4_area": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV4 DefaultOSPFArea on the remote interface.",
										MarkdownDescription: "Reference to a IPV4 DefaultOSPFArea on the remote interface.",
									},
									"remote_ipv4_instance": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV4 DefaultOSPFInstance on the remote interface",
										MarkdownDescription: "Reference to a IPV4 DefaultOSPFInstance on the remote interface",
									},
									"remote_ipv6_area": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV6 DefaultOSPFArea on the remote interface.",
										MarkdownDescription: "Reference to a IPV6 DefaultOSPFArea on the remote interface.",
									},
									"remote_ipv6_instance": schema.StringAttribute{
										Optional:            true,
										Description:         "Reference to a IPV6 DefaultOSPFInstance on the remote interface.",
										MarkdownDescription: "Reference to a IPV6 DefaultOSPFInstance on the remote interface.",
									},
								},
								CustomType: Ospfv3Type{
									ObjectType: types.ObjectType{
										AttrTypes: Ospfv3Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "OSPFv3 Parameters.",
								MarkdownDescription: "OSPFv3 Parameters.",
							},
						},
						CustomType: OspfType{
							ObjectType: types.ObjectType{
								AttrTypes: OspfValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Enable or disable OSPF on the ISL.",
						MarkdownDescription: "Enable or disable OSPF on the ISL.",
					},
					"pool_ipv4": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an IPv4 allocation pool to use for ISL subnet allocations.",
						MarkdownDescription: "Reference to an IPv4 allocation pool to use for ISL subnet allocations.",
					},
					"pool_ipv6": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an IPv6 allocation pool to use for ISL subnet allocations.",
						MarkdownDescription: "Reference to an IPv6 allocation pool to use for ISL subnet allocations.",
					},
					"qos": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"egress_policy": schema.StringAttribute{
								Optional: true,
							},
							"ingress_policy": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: QosType{
							ObjectType: types.ObjectType{
								AttrTypes: QosValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"remote_default_router": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to the DefautlRouter associated with the remote Interface in which the ISL will be provisioned.",
						MarkdownDescription: "Reference to the DefautlRouter associated with the remote Interface in which the ISL will be provisioned.",
					},
					"remote_interface": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an Interface",
						MarkdownDescription: "Reference to an Interface",
					},
					"unnumbered": schema.StringAttribute{
						Optional:            true,
						Description:         "Enables the use of unnumbered interfaces on the ISL. For IPv6, no IP address are configured on the sub-interface and only the link local address will be used. If any allocation pool is specified for IPv6 that will take precedence and IPs will be assigned to the interfaces.  When using eBGP for an underlay protocol, the DefaultInterfaces which are a part of the ISL will be added to the BGP dynamic neighbor list.",
						MarkdownDescription: "Enables the use of unnumbered interfaces on the ISL. For IPv6, no IP address are configured on the sub-interface and only the link local address will be used. If any allocation pool is specified for IPv6 that will take precedence and IPs will be assigned to the interfaces.  When using eBGP for an underlay protocol, the DefaultInterfaces which are a part of the ISL will be added to the BGP dynamic neighbor list.",
					},
					"vlan_id": schema.Int64Attribute{
						Optional:            true,
						Description:         "Single VLAN tag value between 1-4094.",
						MarkdownDescription: "Single VLAN tag value between 1-4094.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "The ISL enables the configuration and management of direct links between Nodes. This resource allows for specifying IPv4 and IPv6 allocation pools, enabling BFD for fast failure detection, and configuring VLAN IDs for the ISL. It also supports BGP peering between the endpoints, with options for setting autonomous systems, AFI/SAFI configurations, and import/export routing policies.",
				MarkdownDescription: "The ISL enables the configuration and management of direct links between Nodes. This resource allows for specifying IPv4 and IPv6 allocation pools, enabling BFD for fast failure detection, and configuring VLAN IDs for the ISL. It also supports BGP peering between the endpoints, with options for setting autonomous systems, AFI/SAFI configurations, and import/export routing policies.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"health": schema.Int64Attribute{
						Computed:            true,
						Description:         "Indicates the health score of the ISL",
						MarkdownDescription: "Indicates the health score of the ISL",
					},
					"health_score_reason": schema.StringAttribute{
						Computed:            true,
						Description:         "Indicates the reason for the health score",
						MarkdownDescription: "Indicates the reason for the health score",
					},
					"last_change": schema.StringAttribute{
						Computed:            true,
						Description:         "The time when the state of the resource last changed",
						MarkdownDescription: "The time when the state of the resource last changed",
					},
					"local_interface": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"default_interface": schema.StringAttribute{
								Computed:            true,
								Description:         "Reference to the DefaulInterface associated with the local interface",
								MarkdownDescription: "Reference to the DefaulInterface associated with the local interface",
							},
							"ipv4_address": schema.StringAttribute{
								Computed:            true,
								Description:         "Local Interface IPv4 address",
								MarkdownDescription: "Local Interface IPv4 address",
							},
							"ipv6_address": schema.StringAttribute{
								Computed:            true,
								Description:         "Local Interface IPv4 address",
								MarkdownDescription: "Local Interface IPv4 address",
							},
							"node": schema.StringAttribute{
								Computed:            true,
								Description:         "Reference to the TopoNode on which the local interface is configured",
								MarkdownDescription: "Reference to the TopoNode on which the local interface is configured",
							},
						},
						CustomType: LocalInterfaceType{
							ObjectType: types.ObjectType{
								AttrTypes: LocalInterfaceValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Local Interface",
						MarkdownDescription: "Local Interface",
					},
					"operational_state": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational state of the ISL",
						MarkdownDescription: "Operational state of the ISL",
					},
					"remote_interface": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"default_interface": schema.StringAttribute{
								Computed:            true,
								Description:         "Reference to the DefaulInterface associated with the remote interface",
								MarkdownDescription: "Reference to the DefaulInterface associated with the remote interface",
							},
							"ipv4_address": schema.StringAttribute{
								Computed:            true,
								Description:         "Remote Interface IPv4 address",
								MarkdownDescription: "Remote Interface IPv4 address",
							},
							"ipv6_address": schema.StringAttribute{
								Computed:            true,
								Description:         "Remote Interface IPv6 address",
								MarkdownDescription: "Remote Interface IPv6 address",
							},
							"node": schema.StringAttribute{
								Computed:            true,
								Description:         "Reference to the TopoNode on which the remote interface is configured",
								MarkdownDescription: "Reference to the TopoNode on which the remote interface is configured",
							},
						},
						CustomType: RemoteInterfaceType{
							ObjectType: types.ObjectType{
								AttrTypes: RemoteInterfaceValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Remote Interface",
						MarkdownDescription: "Remote Interface",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "ISLStatus defines the observed state of ISL",
				MarkdownDescription: "ISLStatus defines the observed state of ISL",
			},
		},
	}
}

type IslModel struct {
	Alarms     AlarmsValue     `tfsdk:"alarms"`
	ApiVersion types.String    `tfsdk:"api_version"`
	Deviations DeviationsValue `tfsdk:"deviations"`
	Hash       types.String    `tfsdk:"hash"`
	Kind       types.String    `tfsdk:"kind"`
	Metadata   MetadataValue   `tfsdk:"metadata"`
	Name       types.String    `tfsdk:"name"`
	Namespace  types.String    `tfsdk:"namespace"`
	Spec       SpecValue       `tfsdk:"spec"`
	Status     StatusValue     `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return nil, diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	localDefaultRouterAttribute, ok := attributes["local_default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_default_router is missing from object`)

		return nil, diags
	}

	localDefaultRouterVal, ok := localDefaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_default_router expected to be basetypes.StringValue, was: %T`, localDefaultRouterAttribute))
	}

	localInterfaceAttribute, ok := attributes["local_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface is missing from object`)

		return nil, diags
	}

	localInterfaceVal, ok := localInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface expected to be basetypes.StringValue, was: %T`, localInterfaceAttribute))
	}

	ospfAttribute, ok := attributes["ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf is missing from object`)

		return nil, diags
	}

	ospfVal, ok := ospfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf expected to be basetypes.ObjectValue, was: %T`, ospfAttribute))
	}

	poolIpv4Attribute, ok := attributes["pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv4 is missing from object`)

		return nil, diags
	}

	poolIpv4Val, ok := poolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv4 expected to be basetypes.StringValue, was: %T`, poolIpv4Attribute))
	}

	poolIpv6Attribute, ok := attributes["pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv6 is missing from object`)

		return nil, diags
	}

	poolIpv6Val, ok := poolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv6 expected to be basetypes.StringValue, was: %T`, poolIpv6Attribute))
	}

	qosAttribute, ok := attributes["qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos is missing from object`)

		return nil, diags
	}

	qosVal, ok := qosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos expected to be basetypes.ObjectValue, was: %T`, qosAttribute))
	}

	remoteDefaultRouterAttribute, ok := attributes["remote_default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_default_router is missing from object`)

		return nil, diags
	}

	remoteDefaultRouterVal, ok := remoteDefaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_default_router expected to be basetypes.StringValue, was: %T`, remoteDefaultRouterAttribute))
	}

	remoteInterfaceAttribute, ok := attributes["remote_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface is missing from object`)

		return nil, diags
	}

	remoteInterfaceVal, ok := remoteInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface expected to be basetypes.StringValue, was: %T`, remoteInterfaceAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return nil, diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Bfd:                 bfdVal,
		Bgp:                 bgpVal,
		IpMtu:               ipMtuVal,
		LocalDefaultRouter:  localDefaultRouterVal,
		LocalInterface:      localInterfaceVal,
		Ospf:                ospfVal,
		PoolIpv4:            poolIpv4Val,
		PoolIpv6:            poolIpv6Val,
		Qos:                 qosVal,
		RemoteDefaultRouter: remoteDefaultRouterVal,
		RemoteInterface:     remoteInterfaceVal,
		Unnumbered:          unnumberedVal,
		VlanId:              vlanIdVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	localDefaultRouterAttribute, ok := attributes["local_default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_default_router is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	localDefaultRouterVal, ok := localDefaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_default_router expected to be basetypes.StringValue, was: %T`, localDefaultRouterAttribute))
	}

	localInterfaceAttribute, ok := attributes["local_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	localInterfaceVal, ok := localInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface expected to be basetypes.StringValue, was: %T`, localInterfaceAttribute))
	}

	ospfAttribute, ok := attributes["ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ospfVal, ok := ospfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf expected to be basetypes.ObjectValue, was: %T`, ospfAttribute))
	}

	poolIpv4Attribute, ok := attributes["pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv4 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	poolIpv4Val, ok := poolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv4 expected to be basetypes.StringValue, was: %T`, poolIpv4Attribute))
	}

	poolIpv6Attribute, ok := attributes["pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv6 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	poolIpv6Val, ok := poolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv6 expected to be basetypes.StringValue, was: %T`, poolIpv6Attribute))
	}

	qosAttribute, ok := attributes["qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	qosVal, ok := qosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos expected to be basetypes.ObjectValue, was: %T`, qosAttribute))
	}

	remoteDefaultRouterAttribute, ok := attributes["remote_default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_default_router is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	remoteDefaultRouterVal, ok := remoteDefaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_default_router expected to be basetypes.StringValue, was: %T`, remoteDefaultRouterAttribute))
	}

	remoteInterfaceAttribute, ok := attributes["remote_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	remoteInterfaceVal, ok := remoteInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface expected to be basetypes.StringValue, was: %T`, remoteInterfaceAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Bfd:                 bfdVal,
		Bgp:                 bgpVal,
		IpMtu:               ipMtuVal,
		LocalDefaultRouter:  localDefaultRouterVal,
		LocalInterface:      localInterfaceVal,
		Ospf:                ospfVal,
		PoolIpv4:            poolIpv4Val,
		PoolIpv6:            poolIpv6Val,
		Qos:                 qosVal,
		RemoteDefaultRouter: remoteDefaultRouterVal,
		RemoteInterface:     remoteInterfaceVal,
		Unnumbered:          unnumberedVal,
		VlanId:              vlanIdVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Bfd                 basetypes.ObjectValue `tfsdk:"bfd"`
	Bgp                 basetypes.ObjectValue `tfsdk:"bgp"`
	IpMtu               basetypes.Int64Value  `tfsdk:"ip_mtu"`
	LocalDefaultRouter  basetypes.StringValue `tfsdk:"local_default_router"`
	LocalInterface      basetypes.StringValue `tfsdk:"local_interface"`
	Ospf                basetypes.ObjectValue `tfsdk:"ospf"`
	PoolIpv4            basetypes.StringValue `tfsdk:"pool_ipv4"`
	PoolIpv6            basetypes.StringValue `tfsdk:"pool_ipv6"`
	Qos                 basetypes.ObjectValue `tfsdk:"qos"`
	RemoteDefaultRouter basetypes.StringValue `tfsdk:"remote_default_router"`
	RemoteInterface     basetypes.StringValue `tfsdk:"remote_interface"`
	Unnumbered          basetypes.StringValue `tfsdk:"unnumbered"`
	VlanId              basetypes.Int64Value  `tfsdk:"vlan_id"`
	state               attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: BfdValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: BgpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["local_default_router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ospf"] = basetypes.ObjectType{
		AttrTypes: OspfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pool_ipv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["qos"] = basetypes.ObjectType{
		AttrTypes: QosValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["remote_default_router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unnumbered"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Bgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.LocalDefaultRouter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_default_router"] = val

		val, err = v.LocalInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_interface"] = val

		val, err = v.Ospf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospf"] = val

		val, err = v.PoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pool_ipv4"] = val

		val, err = v.PoolIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pool_ipv6"] = val

		val, err = v.Qos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos"] = val

		val, err = v.RemoteDefaultRouter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_default_router"] = val

		val, err = v.RemoteInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_interface"] = val

		val, err = v.Unnumbered.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unnumbered"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd basetypes.ObjectValue

	if v.Bfd.IsNull() {
		bfd = types.ObjectNull(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd.IsUnknown() {
		bfd = types.ObjectUnknown(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd.IsNull() && !v.Bfd.IsUnknown() {
		bfd = types.ObjectValueMust(
			BfdValue{}.AttributeTypes(ctx),
			v.Bfd.Attributes(),
		)
	}

	var bgp basetypes.ObjectValue

	if v.Bgp.IsNull() {
		bgp = types.ObjectNull(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp.IsUnknown() {
		bgp = types.ObjectUnknown(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp.IsNull() && !v.Bgp.IsUnknown() {
		bgp = types.ObjectValueMust(
			BgpValue{}.AttributeTypes(ctx),
			v.Bgp.Attributes(),
		)
	}

	var ospf basetypes.ObjectValue

	if v.Ospf.IsNull() {
		ospf = types.ObjectNull(
			OspfValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ospf.IsUnknown() {
		ospf = types.ObjectUnknown(
			OspfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ospf.IsNull() && !v.Ospf.IsUnknown() {
		ospf = types.ObjectValueMust(
			OspfValue{}.AttributeTypes(ctx),
			v.Ospf.Attributes(),
		)
	}

	var qos basetypes.ObjectValue

	if v.Qos.IsNull() {
		qos = types.ObjectNull(
			QosValue{}.AttributeTypes(ctx),
		)
	}

	if v.Qos.IsUnknown() {
		qos = types.ObjectUnknown(
			QosValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Qos.IsNull() && !v.Qos.IsUnknown() {
		qos = types.ObjectValueMust(
			QosValue{}.AttributeTypes(ctx),
			v.Qos.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"ip_mtu":               basetypes.Int64Type{},
		"local_default_router": basetypes.StringType{},
		"local_interface":      basetypes.StringType{},
		"ospf": basetypes.ObjectType{
			AttrTypes: OspfValue{}.AttributeTypes(ctx),
		},
		"pool_ipv4": basetypes.StringType{},
		"pool_ipv6": basetypes.StringType{},
		"qos": basetypes.ObjectType{
			AttrTypes: QosValue{}.AttributeTypes(ctx),
		},
		"remote_default_router": basetypes.StringType{},
		"remote_interface":      basetypes.StringType{},
		"unnumbered":            basetypes.StringType{},
		"vlan_id":               basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd":                   bfd,
			"bgp":                   bgp,
			"ip_mtu":                v.IpMtu,
			"local_default_router":  v.LocalDefaultRouter,
			"local_interface":       v.LocalInterface,
			"ospf":                  ospf,
			"pool_ipv4":             v.PoolIpv4,
			"pool_ipv6":             v.PoolIpv6,
			"qos":                   qos,
			"remote_default_router": v.RemoteDefaultRouter,
			"remote_interface":      v.RemoteInterface,
			"unnumbered":            v.Unnumbered,
			"vlan_id":               v.VlanId,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.Bgp.Equal(other.Bgp) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.LocalDefaultRouter.Equal(other.LocalDefaultRouter) {
		return false
	}

	if !v.LocalInterface.Equal(other.LocalInterface) {
		return false
	}

	if !v.Ospf.Equal(other.Ospf) {
		return false
	}

	if !v.PoolIpv4.Equal(other.PoolIpv4) {
		return false
	}

	if !v.PoolIpv6.Equal(other.PoolIpv6) {
		return false
	}

	if !v.Qos.Equal(other.Qos) {
		return false
	}

	if !v.RemoteDefaultRouter.Equal(other.RemoteDefaultRouter) {
		return false
	}

	if !v.RemoteInterface.Equal(other.RemoteInterface) {
		return false
	}

	if !v.Unnumbered.Equal(other.Unnumbered) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"ip_mtu":               basetypes.Int64Type{},
		"local_default_router": basetypes.StringType{},
		"local_interface":      basetypes.StringType{},
		"ospf": basetypes.ObjectType{
			AttrTypes: OspfValue{}.AttributeTypes(ctx),
		},
		"pool_ipv4": basetypes.StringType{},
		"pool_ipv6": basetypes.StringType{},
		"qos": basetypes.ObjectType{
			AttrTypes: QosValue{}.AttributeTypes(ctx),
		},
		"remote_default_router": basetypes.StringType{},
		"remote_interface":      basetypes.StringType{},
		"unnumbered":            basetypes.StringType{},
		"vlan_id":               basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BfdType{}

type BfdType struct {
	basetypes.ObjectType
}

func (t BfdType) Equal(o attr.Type) bool {
	other, ok := o.(BfdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BfdType) String() string {
	return "BfdType"
}

func (t BfdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return nil, diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return nil, diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return nil, diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return nil, diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return nil, diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueNull() BfdValue {
	return BfdValue{
		state: attr.ValueStateNull,
	}
}

func NewBfdValueUnknown() BfdValue {
	return BfdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBfdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BfdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BfdValue Attribute Value",
				"While creating a BfdValue value, a missing attribute value was detected. "+
					"A BfdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BfdValue Attribute Type",
				"While creating a BfdValue value, an invalid attribute value was detected. "+
					"A BfdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BfdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BfdValue Attribute Value",
				"While creating a BfdValue value, an extra attribute value was detected. "+
					"A BfdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BfdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BfdValue {
	object, diags := NewBfdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BfdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfdValueMust(BfdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BfdType) ValueType(ctx context.Context) attr.Value {
	return BfdValue{}
}

var _ basetypes.ObjectValuable = BfdValue{}

type BfdValue struct {
	DesiredMinTransmitInt  basetypes.Int64Value `tfsdk:"desired_min_transmit_int"`
	DetectionMultiplier    basetypes.Int64Value `tfsdk:"detection_multiplier"`
	Enabled                basetypes.BoolValue  `tfsdk:"enabled"`
	MinEchoReceiveInterval basetypes.Int64Value `tfsdk:"min_echo_receive_interval"`
	RequiredMinReceive     basetypes.Int64Value `tfsdk:"required_min_receive"`
	Ttl                    basetypes.Int64Value `tfsdk:"ttl"`
	state                  attr.ValueState
}

func (v BfdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["desired_min_transmit_int"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["detection_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_echo_receive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required_min_receive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ttl"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DesiredMinTransmitInt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_min_transmit_int"] = val

		val, err = v.DetectionMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detection_multiplier"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MinEchoReceiveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_echo_receive_interval"] = val

		val, err = v.RequiredMinReceive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_min_receive"] = val

		val, err = v.Ttl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ttl"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BfdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BfdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BfdValue) String() string {
	return "BfdValue"
}

func (v BfdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"desired_min_transmit_int":  v.DesiredMinTransmitInt,
			"detection_multiplier":      v.DetectionMultiplier,
			"enabled":                   v.Enabled,
			"min_echo_receive_interval": v.MinEchoReceiveInterval,
			"required_min_receive":      v.RequiredMinReceive,
			"ttl":                       v.Ttl,
		})

	return objVal, diags
}

func (v BfdValue) Equal(o attr.Value) bool {
	other, ok := o.(BfdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DesiredMinTransmitInt.Equal(other.DesiredMinTransmitInt) {
		return false
	}

	if !v.DetectionMultiplier.Equal(other.DetectionMultiplier) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MinEchoReceiveInterval.Equal(other.MinEchoReceiveInterval) {
		return false
	}

	if !v.RequiredMinReceive.Equal(other.RequiredMinReceive) {
		return false
	}

	if !v.Ttl.Equal(other.Ttl) {
		return false
	}

	return true
}

func (v BfdValue) Type(ctx context.Context) attr.Type {
	return BfdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BfdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BgpType{}

type BgpType struct {
	basetypes.ObjectType
}

func (t BgpType) Equal(o attr.Type) bool {
	other, ok := o.(BgpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpType) String() string {
	return "BgpType"
}

func (t BgpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	afiSafiAttribute, ok := attributes["afi_safi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`afi_safi is missing from object`)

		return nil, diags
	}

	afiSafiVal, ok := afiSafiAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`afi_safi expected to be basetypes.ListValue, was: %T`, afiSafiAttribute))
	}

	bgpGroupAttribute, ok := attributes["bgp_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_group is missing from object`)

		return nil, diags
	}

	bgpGroupVal, ok := bgpGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_group expected to be basetypes.StringValue, was: %T`, bgpGroupAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	localInterfaceAsAttribute, ok := attributes["local_interface_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface_as is missing from object`)

		return nil, diags
	}

	localInterfaceAsVal, ok := localInterfaceAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface_as expected to be basetypes.Int64Value, was: %T`, localInterfaceAsAttribute))
	}

	remoteInterfaceAsAttribute, ok := attributes["remote_interface_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface_as is missing from object`)

		return nil, diags
	}

	remoteInterfaceAsVal, ok := remoteInterfaceAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface_as expected to be basetypes.Int64Value, was: %T`, remoteInterfaceAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpValue{
		AfiSafi:           afiSafiVal,
		BgpGroup:          bgpGroupVal,
		Enabled:           enabledVal,
		ExportPolicy:      exportPolicyVal,
		ImportPolicy:      importPolicyVal,
		Keychain:          keychainVal,
		LocalInterfaceAs:  localInterfaceAsVal,
		RemoteInterfaceAs: remoteInterfaceAsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBgpValueNull() BgpValue {
	return BgpValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpValueUnknown() BgpValue {
	return BgpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpValue Attribute Value",
				"While creating a BgpValue value, a missing attribute value was detected. "+
					"A BgpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpValue Attribute Type",
				"While creating a BgpValue value, an invalid attribute value was detected. "+
					"A BgpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpValue Attribute Value",
				"While creating a BgpValue value, an extra attribute value was detected. "+
					"A BgpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	afiSafiAttribute, ok := attributes["afi_safi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`afi_safi is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	afiSafiVal, ok := afiSafiAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`afi_safi expected to be basetypes.ListValue, was: %T`, afiSafiAttribute))
	}

	bgpGroupAttribute, ok := attributes["bgp_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_group is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	bgpGroupVal, ok := bgpGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_group expected to be basetypes.StringValue, was: %T`, bgpGroupAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	localInterfaceAsAttribute, ok := attributes["local_interface_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface_as is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	localInterfaceAsVal, ok := localInterfaceAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface_as expected to be basetypes.Int64Value, was: %T`, localInterfaceAsAttribute))
	}

	remoteInterfaceAsAttribute, ok := attributes["remote_interface_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface_as is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	remoteInterfaceAsVal, ok := remoteInterfaceAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface_as expected to be basetypes.Int64Value, was: %T`, remoteInterfaceAsAttribute))
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	return BgpValue{
		AfiSafi:           afiSafiVal,
		BgpGroup:          bgpGroupVal,
		Enabled:           enabledVal,
		ExportPolicy:      exportPolicyVal,
		ImportPolicy:      importPolicyVal,
		Keychain:          keychainVal,
		LocalInterfaceAs:  localInterfaceAsVal,
		RemoteInterfaceAs: remoteInterfaceAsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBgpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpValue {
	object, diags := NewBgpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpValueMust(BgpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpType) ValueType(ctx context.Context) attr.Value {
	return BgpValue{}
}

var _ basetypes.ObjectValuable = BgpValue{}

type BgpValue struct {
	AfiSafi           basetypes.ListValue   `tfsdk:"afi_safi"`
	BgpGroup          basetypes.StringValue `tfsdk:"bgp_group"`
	Enabled           basetypes.BoolValue   `tfsdk:"enabled"`
	ExportPolicy      basetypes.ListValue   `tfsdk:"export_policy"`
	ImportPolicy      basetypes.ListValue   `tfsdk:"import_policy"`
	Keychain          basetypes.StringValue `tfsdk:"keychain"`
	LocalInterfaceAs  basetypes.Int64Value  `tfsdk:"local_interface_as"`
	RemoteInterfaceAs basetypes.Int64Value  `tfsdk:"remote_interface_as"`
	state             attr.ValueState
}

func (v BgpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["afi_safi"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["bgp_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_interface_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_interface_as"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AfiSafi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["afi_safi"] = val

		val, err = v.BgpGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp_group"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.LocalInterfaceAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_interface_as"] = val

		val, err = v.RemoteInterfaceAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_interface_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpValue) String() string {
	return "BgpValue"
}

func (v BgpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var afiSafiVal basetypes.ListValue
	switch {
	case v.AfiSafi.IsUnknown():
		afiSafiVal = types.ListUnknown(types.StringType)
	case v.AfiSafi.IsNull():
		afiSafiVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		afiSafiVal, d = types.ListValue(types.StringType, v.AfiSafi.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"afi_safi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bgp_group": basetypes.StringType{},
			"enabled":   basetypes.BoolType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain":            basetypes.StringType{},
			"local_interface_as":  basetypes.Int64Type{},
			"remote_interface_as": basetypes.Int64Type{},
		}), diags
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"afi_safi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bgp_group": basetypes.StringType{},
			"enabled":   basetypes.BoolType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain":            basetypes.StringType{},
			"local_interface_as":  basetypes.Int64Type{},
			"remote_interface_as": basetypes.Int64Type{},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"afi_safi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bgp_group": basetypes.StringType{},
			"enabled":   basetypes.BoolType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain":            basetypes.StringType{},
			"local_interface_as":  basetypes.Int64Type{},
			"remote_interface_as": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"afi_safi": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bgp_group": basetypes.StringType{},
		"enabled":   basetypes.BoolType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"keychain":            basetypes.StringType{},
		"local_interface_as":  basetypes.Int64Type{},
		"remote_interface_as": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"afi_safi":            afiSafiVal,
			"bgp_group":           v.BgpGroup,
			"enabled":             v.Enabled,
			"export_policy":       exportPolicyVal,
			"import_policy":       importPolicyVal,
			"keychain":            v.Keychain,
			"local_interface_as":  v.LocalInterfaceAs,
			"remote_interface_as": v.RemoteInterfaceAs,
		})

	return objVal, diags
}

func (v BgpValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AfiSafi.Equal(other.AfiSafi) {
		return false
	}

	if !v.BgpGroup.Equal(other.BgpGroup) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.LocalInterfaceAs.Equal(other.LocalInterfaceAs) {
		return false
	}

	if !v.RemoteInterfaceAs.Equal(other.RemoteInterfaceAs) {
		return false
	}

	return true
}

func (v BgpValue) Type(ctx context.Context) attr.Type {
	return BgpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"afi_safi": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bgp_group": basetypes.StringType{},
		"enabled":   basetypes.BoolType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"keychain":            basetypes.StringType{},
		"local_interface_as":  basetypes.Int64Type{},
		"remote_interface_as": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = OspfType{}

type OspfType struct {
	basetypes.ObjectType
}

func (t OspfType) Equal(o attr.Type) bool {
	other, ok := o.(OspfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfType) String() string {
	return "OspfType"
}

func (t OspfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ospfv2Attribute, ok := attributes["ospfv2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospfv2 is missing from object`)

		return nil, diags
	}

	ospfv2Val, ok := ospfv2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospfv2 expected to be basetypes.ObjectValue, was: %T`, ospfv2Attribute))
	}

	ospfv3Attribute, ok := attributes["ospfv3"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospfv3 is missing from object`)

		return nil, diags
	}

	ospfv3Val, ok := ospfv3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospfv3 expected to be basetypes.ObjectValue, was: %T`, ospfv3Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfValue{
		Enabled: enabledVal,
		Ospfv2:  ospfv2Val,
		Ospfv3:  ospfv3Val,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewOspfValueNull() OspfValue {
	return OspfValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfValueUnknown() OspfValue {
	return OspfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfValue Attribute Value",
				"While creating a OspfValue value, a missing attribute value was detected. "+
					"A OspfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfValue Attribute Type",
				"While creating a OspfValue value, an invalid attribute value was detected. "+
					"A OspfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfValue Attribute Value",
				"While creating a OspfValue value, an extra attribute value was detected. "+
					"A OspfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewOspfValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ospfv2Attribute, ok := attributes["ospfv2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospfv2 is missing from object`)

		return NewOspfValueUnknown(), diags
	}

	ospfv2Val, ok := ospfv2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospfv2 expected to be basetypes.ObjectValue, was: %T`, ospfv2Attribute))
	}

	ospfv3Attribute, ok := attributes["ospfv3"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospfv3 is missing from object`)

		return NewOspfValueUnknown(), diags
	}

	ospfv3Val, ok := ospfv3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospfv3 expected to be basetypes.ObjectValue, was: %T`, ospfv3Attribute))
	}

	if diags.HasError() {
		return NewOspfValueUnknown(), diags
	}

	return OspfValue{
		Enabled: enabledVal,
		Ospfv2:  ospfv2Val,
		Ospfv3:  ospfv3Val,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewOspfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfValue {
	object, diags := NewOspfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfValueMust(OspfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfType) ValueType(ctx context.Context) attr.Value {
	return OspfValue{}
}

var _ basetypes.ObjectValuable = OspfValue{}

type OspfValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Ospfv2  basetypes.ObjectValue `tfsdk:"ospfv2"`
	Ospfv3  basetypes.ObjectValue `tfsdk:"ospfv3"`
	state   attr.ValueState
}

func (v OspfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ospfv2"] = basetypes.ObjectType{
		AttrTypes: Ospfv2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ospfv3"] = basetypes.ObjectType{
		AttrTypes: Ospfv3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Ospfv2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospfv2"] = val

		val, err = v.Ospfv3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospfv3"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfValue) String() string {
	return "OspfValue"
}

func (v OspfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ospfv2 basetypes.ObjectValue

	if v.Ospfv2.IsNull() {
		ospfv2 = types.ObjectNull(
			Ospfv2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ospfv2.IsUnknown() {
		ospfv2 = types.ObjectUnknown(
			Ospfv2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ospfv2.IsNull() && !v.Ospfv2.IsUnknown() {
		ospfv2 = types.ObjectValueMust(
			Ospfv2Value{}.AttributeTypes(ctx),
			v.Ospfv2.Attributes(),
		)
	}

	var ospfv3 basetypes.ObjectValue

	if v.Ospfv3.IsNull() {
		ospfv3 = types.ObjectNull(
			Ospfv3Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ospfv3.IsUnknown() {
		ospfv3 = types.ObjectUnknown(
			Ospfv3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ospfv3.IsNull() && !v.Ospfv3.IsUnknown() {
		ospfv3 = types.ObjectValueMust(
			Ospfv3Value{}.AttributeTypes(ctx),
			v.Ospfv3.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"ospfv2": basetypes.ObjectType{
			AttrTypes: Ospfv2Value{}.AttributeTypes(ctx),
		},
		"ospfv3": basetypes.ObjectType{
			AttrTypes: Ospfv3Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"ospfv2":  ospfv2,
			"ospfv3":  ospfv3,
		})

	return objVal, diags
}

func (v OspfValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Ospfv2.Equal(other.Ospfv2) {
		return false
	}

	if !v.Ospfv3.Equal(other.Ospfv3) {
		return false
	}

	return true
}

func (v OspfValue) Type(ctx context.Context) attr.Type {
	return OspfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"ospfv2": basetypes.ObjectType{
			AttrTypes: Ospfv2Value{}.AttributeTypes(ctx),
		},
		"ospfv3": basetypes.ObjectType{
			AttrTypes: Ospfv3Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Ospfv2Type{}

type Ospfv2Type struct {
	basetypes.ObjectType
}

func (t Ospfv2Type) Equal(o attr.Type) bool {
	other, ok := o.(Ospfv2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ospfv2Type) String() string {
	return "Ospfv2Type"
}

func (t Ospfv2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	localIpv4AreaAttribute, ok := attributes["local_ipv4_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv4_area is missing from object`)

		return nil, diags
	}

	localIpv4AreaVal, ok := localIpv4AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv4_area expected to be basetypes.StringValue, was: %T`, localIpv4AreaAttribute))
	}

	localIpv4InstanceAttribute, ok := attributes["local_ipv4_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv4_instance is missing from object`)

		return nil, diags
	}

	localIpv4InstanceVal, ok := localIpv4InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv4_instance expected to be basetypes.StringValue, was: %T`, localIpv4InstanceAttribute))
	}

	remoteIpv4AreaAttribute, ok := attributes["remote_ipv4_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv4_area is missing from object`)

		return nil, diags
	}

	remoteIpv4AreaVal, ok := remoteIpv4AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv4_area expected to be basetypes.StringValue, was: %T`, remoteIpv4AreaAttribute))
	}

	remoteIpv4InstanceAttribute, ok := attributes["remote_ipv4_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv4_instance is missing from object`)

		return nil, diags
	}

	remoteIpv4InstanceVal, ok := remoteIpv4InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv4_instance expected to be basetypes.StringValue, was: %T`, remoteIpv4InstanceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ospfv2Value{
		LocalIpv4Area:      localIpv4AreaVal,
		LocalIpv4Instance:  localIpv4InstanceVal,
		RemoteIpv4Area:     remoteIpv4AreaVal,
		RemoteIpv4Instance: remoteIpv4InstanceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOspfv2ValueNull() Ospfv2Value {
	return Ospfv2Value{
		state: attr.ValueStateNull,
	}
}

func NewOspfv2ValueUnknown() Ospfv2Value {
	return Ospfv2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfv2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ospfv2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ospfv2Value Attribute Value",
				"While creating a Ospfv2Value value, a missing attribute value was detected. "+
					"A Ospfv2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ospfv2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ospfv2Value Attribute Type",
				"While creating a Ospfv2Value value, an invalid attribute value was detected. "+
					"A Ospfv2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ospfv2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ospfv2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ospfv2Value Attribute Value",
				"While creating a Ospfv2Value value, an extra attribute value was detected. "+
					"A Ospfv2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ospfv2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfv2ValueUnknown(), diags
	}

	localIpv4AreaAttribute, ok := attributes["local_ipv4_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv4_area is missing from object`)

		return NewOspfv2ValueUnknown(), diags
	}

	localIpv4AreaVal, ok := localIpv4AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv4_area expected to be basetypes.StringValue, was: %T`, localIpv4AreaAttribute))
	}

	localIpv4InstanceAttribute, ok := attributes["local_ipv4_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv4_instance is missing from object`)

		return NewOspfv2ValueUnknown(), diags
	}

	localIpv4InstanceVal, ok := localIpv4InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv4_instance expected to be basetypes.StringValue, was: %T`, localIpv4InstanceAttribute))
	}

	remoteIpv4AreaAttribute, ok := attributes["remote_ipv4_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv4_area is missing from object`)

		return NewOspfv2ValueUnknown(), diags
	}

	remoteIpv4AreaVal, ok := remoteIpv4AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv4_area expected to be basetypes.StringValue, was: %T`, remoteIpv4AreaAttribute))
	}

	remoteIpv4InstanceAttribute, ok := attributes["remote_ipv4_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv4_instance is missing from object`)

		return NewOspfv2ValueUnknown(), diags
	}

	remoteIpv4InstanceVal, ok := remoteIpv4InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv4_instance expected to be basetypes.StringValue, was: %T`, remoteIpv4InstanceAttribute))
	}

	if diags.HasError() {
		return NewOspfv2ValueUnknown(), diags
	}

	return Ospfv2Value{
		LocalIpv4Area:      localIpv4AreaVal,
		LocalIpv4Instance:  localIpv4InstanceVal,
		RemoteIpv4Area:     remoteIpv4AreaVal,
		RemoteIpv4Instance: remoteIpv4InstanceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOspfv2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ospfv2Value {
	object, diags := NewOspfv2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfv2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ospfv2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfv2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfv2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfv2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfv2ValueMust(Ospfv2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ospfv2Type) ValueType(ctx context.Context) attr.Value {
	return Ospfv2Value{}
}

var _ basetypes.ObjectValuable = Ospfv2Value{}

type Ospfv2Value struct {
	LocalIpv4Area      basetypes.StringValue `tfsdk:"local_ipv4_area"`
	LocalIpv4Instance  basetypes.StringValue `tfsdk:"local_ipv4_instance"`
	RemoteIpv4Area     basetypes.StringValue `tfsdk:"remote_ipv4_area"`
	RemoteIpv4Instance basetypes.StringValue `tfsdk:"remote_ipv4_instance"`
	state              attr.ValueState
}

func (v Ospfv2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["local_ipv4_area"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_ipv4_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_ipv4_area"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_ipv4_instance"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.LocalIpv4Area.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_ipv4_area"] = val

		val, err = v.LocalIpv4Instance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_ipv4_instance"] = val

		val, err = v.RemoteIpv4Area.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ipv4_area"] = val

		val, err = v.RemoteIpv4Instance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ipv4_instance"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ospfv2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ospfv2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ospfv2Value) String() string {
	return "Ospfv2Value"
}

func (v Ospfv2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"local_ipv4_area":      basetypes.StringType{},
		"local_ipv4_instance":  basetypes.StringType{},
		"remote_ipv4_area":     basetypes.StringType{},
		"remote_ipv4_instance": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"local_ipv4_area":      v.LocalIpv4Area,
			"local_ipv4_instance":  v.LocalIpv4Instance,
			"remote_ipv4_area":     v.RemoteIpv4Area,
			"remote_ipv4_instance": v.RemoteIpv4Instance,
		})

	return objVal, diags
}

func (v Ospfv2Value) Equal(o attr.Value) bool {
	other, ok := o.(Ospfv2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LocalIpv4Area.Equal(other.LocalIpv4Area) {
		return false
	}

	if !v.LocalIpv4Instance.Equal(other.LocalIpv4Instance) {
		return false
	}

	if !v.RemoteIpv4Area.Equal(other.RemoteIpv4Area) {
		return false
	}

	if !v.RemoteIpv4Instance.Equal(other.RemoteIpv4Instance) {
		return false
	}

	return true
}

func (v Ospfv2Value) Type(ctx context.Context) attr.Type {
	return Ospfv2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ospfv2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"local_ipv4_area":      basetypes.StringType{},
		"local_ipv4_instance":  basetypes.StringType{},
		"remote_ipv4_area":     basetypes.StringType{},
		"remote_ipv4_instance": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ospfv3Type{}

type Ospfv3Type struct {
	basetypes.ObjectType
}

func (t Ospfv3Type) Equal(o attr.Type) bool {
	other, ok := o.(Ospfv3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ospfv3Type) String() string {
	return "Ospfv3Type"
}

func (t Ospfv3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	localIpv4AreaAttribute, ok := attributes["local_ipv4_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv4_area is missing from object`)

		return nil, diags
	}

	localIpv4AreaVal, ok := localIpv4AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv4_area expected to be basetypes.StringValue, was: %T`, localIpv4AreaAttribute))
	}

	localIpv4InstanceAttribute, ok := attributes["local_ipv4_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv4_instance is missing from object`)

		return nil, diags
	}

	localIpv4InstanceVal, ok := localIpv4InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv4_instance expected to be basetypes.StringValue, was: %T`, localIpv4InstanceAttribute))
	}

	localIpv6AreaAttribute, ok := attributes["local_ipv6_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv6_area is missing from object`)

		return nil, diags
	}

	localIpv6AreaVal, ok := localIpv6AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv6_area expected to be basetypes.StringValue, was: %T`, localIpv6AreaAttribute))
	}

	localIpv6InstanceAttribute, ok := attributes["local_ipv6_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv6_instance is missing from object`)

		return nil, diags
	}

	localIpv6InstanceVal, ok := localIpv6InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv6_instance expected to be basetypes.StringValue, was: %T`, localIpv6InstanceAttribute))
	}

	remoteIpv4AreaAttribute, ok := attributes["remote_ipv4_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv4_area is missing from object`)

		return nil, diags
	}

	remoteIpv4AreaVal, ok := remoteIpv4AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv4_area expected to be basetypes.StringValue, was: %T`, remoteIpv4AreaAttribute))
	}

	remoteIpv4InstanceAttribute, ok := attributes["remote_ipv4_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv4_instance is missing from object`)

		return nil, diags
	}

	remoteIpv4InstanceVal, ok := remoteIpv4InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv4_instance expected to be basetypes.StringValue, was: %T`, remoteIpv4InstanceAttribute))
	}

	remoteIpv6AreaAttribute, ok := attributes["remote_ipv6_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv6_area is missing from object`)

		return nil, diags
	}

	remoteIpv6AreaVal, ok := remoteIpv6AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv6_area expected to be basetypes.StringValue, was: %T`, remoteIpv6AreaAttribute))
	}

	remoteIpv6InstanceAttribute, ok := attributes["remote_ipv6_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv6_instance is missing from object`)

		return nil, diags
	}

	remoteIpv6InstanceVal, ok := remoteIpv6InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv6_instance expected to be basetypes.StringValue, was: %T`, remoteIpv6InstanceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ospfv3Value{
		LocalIpv4Area:      localIpv4AreaVal,
		LocalIpv4Instance:  localIpv4InstanceVal,
		LocalIpv6Area:      localIpv6AreaVal,
		LocalIpv6Instance:  localIpv6InstanceVal,
		RemoteIpv4Area:     remoteIpv4AreaVal,
		RemoteIpv4Instance: remoteIpv4InstanceVal,
		RemoteIpv6Area:     remoteIpv6AreaVal,
		RemoteIpv6Instance: remoteIpv6InstanceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOspfv3ValueNull() Ospfv3Value {
	return Ospfv3Value{
		state: attr.ValueStateNull,
	}
}

func NewOspfv3ValueUnknown() Ospfv3Value {
	return Ospfv3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfv3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ospfv3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ospfv3Value Attribute Value",
				"While creating a Ospfv3Value value, a missing attribute value was detected. "+
					"A Ospfv3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ospfv3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ospfv3Value Attribute Type",
				"While creating a Ospfv3Value value, an invalid attribute value was detected. "+
					"A Ospfv3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ospfv3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ospfv3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ospfv3Value Attribute Value",
				"While creating a Ospfv3Value value, an extra attribute value was detected. "+
					"A Ospfv3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ospfv3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfv3ValueUnknown(), diags
	}

	localIpv4AreaAttribute, ok := attributes["local_ipv4_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv4_area is missing from object`)

		return NewOspfv3ValueUnknown(), diags
	}

	localIpv4AreaVal, ok := localIpv4AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv4_area expected to be basetypes.StringValue, was: %T`, localIpv4AreaAttribute))
	}

	localIpv4InstanceAttribute, ok := attributes["local_ipv4_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv4_instance is missing from object`)

		return NewOspfv3ValueUnknown(), diags
	}

	localIpv4InstanceVal, ok := localIpv4InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv4_instance expected to be basetypes.StringValue, was: %T`, localIpv4InstanceAttribute))
	}

	localIpv6AreaAttribute, ok := attributes["local_ipv6_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv6_area is missing from object`)

		return NewOspfv3ValueUnknown(), diags
	}

	localIpv6AreaVal, ok := localIpv6AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv6_area expected to be basetypes.StringValue, was: %T`, localIpv6AreaAttribute))
	}

	localIpv6InstanceAttribute, ok := attributes["local_ipv6_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_ipv6_instance is missing from object`)

		return NewOspfv3ValueUnknown(), diags
	}

	localIpv6InstanceVal, ok := localIpv6InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_ipv6_instance expected to be basetypes.StringValue, was: %T`, localIpv6InstanceAttribute))
	}

	remoteIpv4AreaAttribute, ok := attributes["remote_ipv4_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv4_area is missing from object`)

		return NewOspfv3ValueUnknown(), diags
	}

	remoteIpv4AreaVal, ok := remoteIpv4AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv4_area expected to be basetypes.StringValue, was: %T`, remoteIpv4AreaAttribute))
	}

	remoteIpv4InstanceAttribute, ok := attributes["remote_ipv4_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv4_instance is missing from object`)

		return NewOspfv3ValueUnknown(), diags
	}

	remoteIpv4InstanceVal, ok := remoteIpv4InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv4_instance expected to be basetypes.StringValue, was: %T`, remoteIpv4InstanceAttribute))
	}

	remoteIpv6AreaAttribute, ok := attributes["remote_ipv6_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv6_area is missing from object`)

		return NewOspfv3ValueUnknown(), diags
	}

	remoteIpv6AreaVal, ok := remoteIpv6AreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv6_area expected to be basetypes.StringValue, was: %T`, remoteIpv6AreaAttribute))
	}

	remoteIpv6InstanceAttribute, ok := attributes["remote_ipv6_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ipv6_instance is missing from object`)

		return NewOspfv3ValueUnknown(), diags
	}

	remoteIpv6InstanceVal, ok := remoteIpv6InstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ipv6_instance expected to be basetypes.StringValue, was: %T`, remoteIpv6InstanceAttribute))
	}

	if diags.HasError() {
		return NewOspfv3ValueUnknown(), diags
	}

	return Ospfv3Value{
		LocalIpv4Area:      localIpv4AreaVal,
		LocalIpv4Instance:  localIpv4InstanceVal,
		LocalIpv6Area:      localIpv6AreaVal,
		LocalIpv6Instance:  localIpv6InstanceVal,
		RemoteIpv4Area:     remoteIpv4AreaVal,
		RemoteIpv4Instance: remoteIpv4InstanceVal,
		RemoteIpv6Area:     remoteIpv6AreaVal,
		RemoteIpv6Instance: remoteIpv6InstanceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOspfv3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ospfv3Value {
	object, diags := NewOspfv3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfv3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ospfv3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfv3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfv3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfv3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfv3ValueMust(Ospfv3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ospfv3Type) ValueType(ctx context.Context) attr.Value {
	return Ospfv3Value{}
}

var _ basetypes.ObjectValuable = Ospfv3Value{}

type Ospfv3Value struct {
	LocalIpv4Area      basetypes.StringValue `tfsdk:"local_ipv4_area"`
	LocalIpv4Instance  basetypes.StringValue `tfsdk:"local_ipv4_instance"`
	LocalIpv6Area      basetypes.StringValue `tfsdk:"local_ipv6_area"`
	LocalIpv6Instance  basetypes.StringValue `tfsdk:"local_ipv6_instance"`
	RemoteIpv4Area     basetypes.StringValue `tfsdk:"remote_ipv4_area"`
	RemoteIpv4Instance basetypes.StringValue `tfsdk:"remote_ipv4_instance"`
	RemoteIpv6Area     basetypes.StringValue `tfsdk:"remote_ipv6_area"`
	RemoteIpv6Instance basetypes.StringValue `tfsdk:"remote_ipv6_instance"`
	state              attr.ValueState
}

func (v Ospfv3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["local_ipv4_area"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_ipv4_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_ipv6_area"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_ipv6_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_ipv4_area"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_ipv4_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_ipv6_area"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_ipv6_instance"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.LocalIpv4Area.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_ipv4_area"] = val

		val, err = v.LocalIpv4Instance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_ipv4_instance"] = val

		val, err = v.LocalIpv6Area.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_ipv6_area"] = val

		val, err = v.LocalIpv6Instance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_ipv6_instance"] = val

		val, err = v.RemoteIpv4Area.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ipv4_area"] = val

		val, err = v.RemoteIpv4Instance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ipv4_instance"] = val

		val, err = v.RemoteIpv6Area.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ipv6_area"] = val

		val, err = v.RemoteIpv6Instance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ipv6_instance"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ospfv3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ospfv3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ospfv3Value) String() string {
	return "Ospfv3Value"
}

func (v Ospfv3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"local_ipv4_area":      basetypes.StringType{},
		"local_ipv4_instance":  basetypes.StringType{},
		"local_ipv6_area":      basetypes.StringType{},
		"local_ipv6_instance":  basetypes.StringType{},
		"remote_ipv4_area":     basetypes.StringType{},
		"remote_ipv4_instance": basetypes.StringType{},
		"remote_ipv6_area":     basetypes.StringType{},
		"remote_ipv6_instance": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"local_ipv4_area":      v.LocalIpv4Area,
			"local_ipv4_instance":  v.LocalIpv4Instance,
			"local_ipv6_area":      v.LocalIpv6Area,
			"local_ipv6_instance":  v.LocalIpv6Instance,
			"remote_ipv4_area":     v.RemoteIpv4Area,
			"remote_ipv4_instance": v.RemoteIpv4Instance,
			"remote_ipv6_area":     v.RemoteIpv6Area,
			"remote_ipv6_instance": v.RemoteIpv6Instance,
		})

	return objVal, diags
}

func (v Ospfv3Value) Equal(o attr.Value) bool {
	other, ok := o.(Ospfv3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LocalIpv4Area.Equal(other.LocalIpv4Area) {
		return false
	}

	if !v.LocalIpv4Instance.Equal(other.LocalIpv4Instance) {
		return false
	}

	if !v.LocalIpv6Area.Equal(other.LocalIpv6Area) {
		return false
	}

	if !v.LocalIpv6Instance.Equal(other.LocalIpv6Instance) {
		return false
	}

	if !v.RemoteIpv4Area.Equal(other.RemoteIpv4Area) {
		return false
	}

	if !v.RemoteIpv4Instance.Equal(other.RemoteIpv4Instance) {
		return false
	}

	if !v.RemoteIpv6Area.Equal(other.RemoteIpv6Area) {
		return false
	}

	if !v.RemoteIpv6Instance.Equal(other.RemoteIpv6Instance) {
		return false
	}

	return true
}

func (v Ospfv3Value) Type(ctx context.Context) attr.Type {
	return Ospfv3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ospfv3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"local_ipv4_area":      basetypes.StringType{},
		"local_ipv4_instance":  basetypes.StringType{},
		"local_ipv6_area":      basetypes.StringType{},
		"local_ipv6_instance":  basetypes.StringType{},
		"remote_ipv4_area":     basetypes.StringType{},
		"remote_ipv4_instance": basetypes.StringType{},
		"remote_ipv6_area":     basetypes.StringType{},
		"remote_ipv6_instance": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = QosType{}

type QosType struct {
	basetypes.ObjectType
}

func (t QosType) Equal(o attr.Type) bool {
	other, ok := o.(QosType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QosType) String() string {
	return "QosType"
}

func (t QosType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	egressPolicyAttribute, ok := attributes["egress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_policy is missing from object`)

		return nil, diags
	}

	egressPolicyVal, ok := egressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_policy expected to be basetypes.StringValue, was: %T`, egressPolicyAttribute))
	}

	ingressPolicyAttribute, ok := attributes["ingress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_policy is missing from object`)

		return nil, diags
	}

	ingressPolicyVal, ok := ingressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_policy expected to be basetypes.StringValue, was: %T`, ingressPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QosValue{
		EgressPolicy:  egressPolicyVal,
		IngressPolicy: ingressPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewQosValueNull() QosValue {
	return QosValue{
		state: attr.ValueStateNull,
	}
}

func NewQosValueUnknown() QosValue {
	return QosValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQosValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QosValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QosValue Attribute Value",
				"While creating a QosValue value, a missing attribute value was detected. "+
					"A QosValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QosValue Attribute Type",
				"While creating a QosValue value, an invalid attribute value was detected. "+
					"A QosValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QosValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QosValue Attribute Value",
				"While creating a QosValue value, an extra attribute value was detected. "+
					"A QosValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QosValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	egressPolicyAttribute, ok := attributes["egress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_policy is missing from object`)

		return NewQosValueUnknown(), diags
	}

	egressPolicyVal, ok := egressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_policy expected to be basetypes.StringValue, was: %T`, egressPolicyAttribute))
	}

	ingressPolicyAttribute, ok := attributes["ingress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_policy is missing from object`)

		return NewQosValueUnknown(), diags
	}

	ingressPolicyVal, ok := ingressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_policy expected to be basetypes.StringValue, was: %T`, ingressPolicyAttribute))
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	return QosValue{
		EgressPolicy:  egressPolicyVal,
		IngressPolicy: ingressPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewQosValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QosValue {
	object, diags := NewQosValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQosValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QosType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQosValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQosValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQosValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQosValueMust(QosValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QosType) ValueType(ctx context.Context) attr.Value {
	return QosValue{}
}

var _ basetypes.ObjectValuable = QosValue{}

type QosValue struct {
	EgressPolicy  basetypes.StringValue `tfsdk:"egress_policy"`
	IngressPolicy basetypes.StringValue `tfsdk:"ingress_policy"`
	state         attr.ValueState
}

func (v QosValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["egress_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ingress_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EgressPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress_policy"] = val

		val, err = v.IngressPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QosValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QosValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QosValue) String() string {
	return "QosValue"
}

func (v QosValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"egress_policy":  basetypes.StringType{},
		"ingress_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"egress_policy":  v.EgressPolicy,
			"ingress_policy": v.IngressPolicy,
		})

	return objVal, diags
}

func (v QosValue) Equal(o attr.Value) bool {
	other, ok := o.(QosValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EgressPolicy.Equal(other.EgressPolicy) {
		return false
	}

	if !v.IngressPolicy.Equal(other.IngressPolicy) {
		return false
	}

	return true
}

func (v QosValue) Type(ctx context.Context) attr.Type {
	return QosType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QosValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"egress_policy":  basetypes.StringType{},
		"ingress_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	localInterfaceAttribute, ok := attributes["local_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface is missing from object`)

		return nil, diags
	}

	localInterfaceVal, ok := localInterfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface expected to be basetypes.ObjectValue, was: %T`, localInterfaceAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	remoteInterfaceAttribute, ok := attributes["remote_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface is missing from object`)

		return nil, diags
	}

	remoteInterfaceVal, ok := remoteInterfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface expected to be basetypes.ObjectValue, was: %T`, remoteInterfaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		LocalInterface:    localInterfaceVal,
		OperationalState:  operationalStateVal,
		RemoteInterface:   remoteInterfaceVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	localInterfaceAttribute, ok := attributes["local_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	localInterfaceVal, ok := localInterfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface expected to be basetypes.ObjectValue, was: %T`, localInterfaceAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	remoteInterfaceAttribute, ok := attributes["remote_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	remoteInterfaceVal, ok := remoteInterfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface expected to be basetypes.ObjectValue, was: %T`, remoteInterfaceAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		LocalInterface:    localInterfaceVal,
		OperationalState:  operationalStateVal,
		RemoteInterface:   remoteInterfaceVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	LocalInterface    basetypes.ObjectValue `tfsdk:"local_interface"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	RemoteInterface   basetypes.ObjectValue `tfsdk:"remote_interface"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_interface"] = basetypes.ObjectType{
		AttrTypes: LocalInterfaceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_interface"] = basetypes.ObjectType{
		AttrTypes: RemoteInterfaceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.LocalInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_interface"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.RemoteInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_interface"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var localInterface basetypes.ObjectValue

	if v.LocalInterface.IsNull() {
		localInterface = types.ObjectNull(
			LocalInterfaceValue{}.AttributeTypes(ctx),
		)
	}

	if v.LocalInterface.IsUnknown() {
		localInterface = types.ObjectUnknown(
			LocalInterfaceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalInterface.IsNull() && !v.LocalInterface.IsUnknown() {
		localInterface = types.ObjectValueMust(
			LocalInterfaceValue{}.AttributeTypes(ctx),
			v.LocalInterface.Attributes(),
		)
	}

	var remoteInterface basetypes.ObjectValue

	if v.RemoteInterface.IsNull() {
		remoteInterface = types.ObjectNull(
			RemoteInterfaceValue{}.AttributeTypes(ctx),
		)
	}

	if v.RemoteInterface.IsUnknown() {
		remoteInterface = types.ObjectUnknown(
			RemoteInterfaceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RemoteInterface.IsNull() && !v.RemoteInterface.IsUnknown() {
		remoteInterface = types.ObjectValueMust(
			RemoteInterfaceValue{}.AttributeTypes(ctx),
			v.RemoteInterface.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"local_interface": basetypes.ObjectType{
			AttrTypes: LocalInterfaceValue{}.AttributeTypes(ctx),
		},
		"operational_state": basetypes.StringType{},
		"remote_interface": basetypes.ObjectType{
			AttrTypes: RemoteInterfaceValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"last_change":         v.LastChange,
			"local_interface":     localInterface,
			"operational_state":   v.OperationalState,
			"remote_interface":    remoteInterface,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.LocalInterface.Equal(other.LocalInterface) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.RemoteInterface.Equal(other.RemoteInterface) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"local_interface": basetypes.ObjectType{
			AttrTypes: LocalInterfaceValue{}.AttributeTypes(ctx),
		},
		"operational_state": basetypes.StringType{},
		"remote_interface": basetypes.ObjectType{
			AttrTypes: RemoteInterfaceValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = LocalInterfaceType{}

type LocalInterfaceType struct {
	basetypes.ObjectType
}

func (t LocalInterfaceType) Equal(o attr.Type) bool {
	other, ok := o.(LocalInterfaceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalInterfaceType) String() string {
	return "LocalInterfaceType"
}

func (t LocalInterfaceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultInterfaceAttribute, ok := attributes["default_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_interface is missing from object`)

		return nil, diags
	}

	defaultInterfaceVal, ok := defaultInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_interface expected to be basetypes.StringValue, was: %T`, defaultInterfaceAttribute))
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return nil, diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.StringValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return nil, diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.StringValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalInterfaceValue{
		DefaultInterface: defaultInterfaceVal,
		Ipv4Address:      ipv4AddressVal,
		Ipv6Address:      ipv6AddressVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalInterfaceValueNull() LocalInterfaceValue {
	return LocalInterfaceValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalInterfaceValueUnknown() LocalInterfaceValue {
	return LocalInterfaceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalInterfaceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalInterfaceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalInterfaceValue Attribute Value",
				"While creating a LocalInterfaceValue value, a missing attribute value was detected. "+
					"A LocalInterfaceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalInterfaceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalInterfaceValue Attribute Type",
				"While creating a LocalInterfaceValue value, an invalid attribute value was detected. "+
					"A LocalInterfaceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalInterfaceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalInterfaceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalInterfaceValue Attribute Value",
				"While creating a LocalInterfaceValue value, an extra attribute value was detected. "+
					"A LocalInterfaceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalInterfaceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalInterfaceValueUnknown(), diags
	}

	defaultInterfaceAttribute, ok := attributes["default_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_interface is missing from object`)

		return NewLocalInterfaceValueUnknown(), diags
	}

	defaultInterfaceVal, ok := defaultInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_interface expected to be basetypes.StringValue, was: %T`, defaultInterfaceAttribute))
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return NewLocalInterfaceValueUnknown(), diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.StringValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return NewLocalInterfaceValueUnknown(), diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.StringValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewLocalInterfaceValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewLocalInterfaceValueUnknown(), diags
	}

	return LocalInterfaceValue{
		DefaultInterface: defaultInterfaceVal,
		Ipv4Address:      ipv4AddressVal,
		Ipv6Address:      ipv6AddressVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalInterfaceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalInterfaceValue {
	object, diags := NewLocalInterfaceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalInterfaceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalInterfaceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalInterfaceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalInterfaceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalInterfaceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalInterfaceValueMust(LocalInterfaceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalInterfaceType) ValueType(ctx context.Context) attr.Value {
	return LocalInterfaceValue{}
}

var _ basetypes.ObjectValuable = LocalInterfaceValue{}

type LocalInterfaceValue struct {
	DefaultInterface basetypes.StringValue `tfsdk:"default_interface"`
	Ipv4Address      basetypes.StringValue `tfsdk:"ipv4_address"`
	Ipv6Address      basetypes.StringValue `tfsdk:"ipv6_address"`
	Node             basetypes.StringValue `tfsdk:"node"`
	state            attr.ValueState
}

func (v LocalInterfaceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["default_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv4_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DefaultInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_interface"] = val

		val, err = v.Ipv4Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_address"] = val

		val, err = v.Ipv6Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_address"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalInterfaceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalInterfaceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalInterfaceValue) String() string {
	return "LocalInterfaceValue"
}

func (v LocalInterfaceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"default_interface": basetypes.StringType{},
		"ipv4_address":      basetypes.StringType{},
		"ipv6_address":      basetypes.StringType{},
		"node":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_interface": v.DefaultInterface,
			"ipv4_address":      v.Ipv4Address,
			"ipv6_address":      v.Ipv6Address,
			"node":              v.Node,
		})

	return objVal, diags
}

func (v LocalInterfaceValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalInterfaceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultInterface.Equal(other.DefaultInterface) {
		return false
	}

	if !v.Ipv4Address.Equal(other.Ipv4Address) {
		return false
	}

	if !v.Ipv6Address.Equal(other.Ipv6Address) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v LocalInterfaceValue) Type(ctx context.Context) attr.Type {
	return LocalInterfaceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalInterfaceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_interface": basetypes.StringType{},
		"ipv4_address":      basetypes.StringType{},
		"ipv6_address":      basetypes.StringType{},
		"node":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteInterfaceType{}

type RemoteInterfaceType struct {
	basetypes.ObjectType
}

func (t RemoteInterfaceType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteInterfaceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteInterfaceType) String() string {
	return "RemoteInterfaceType"
}

func (t RemoteInterfaceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultInterfaceAttribute, ok := attributes["default_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_interface is missing from object`)

		return nil, diags
	}

	defaultInterfaceVal, ok := defaultInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_interface expected to be basetypes.StringValue, was: %T`, defaultInterfaceAttribute))
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return nil, diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.StringValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return nil, diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.StringValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteInterfaceValue{
		DefaultInterface: defaultInterfaceVal,
		Ipv4Address:      ipv4AddressVal,
		Ipv6Address:      ipv6AddressVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteInterfaceValueNull() RemoteInterfaceValue {
	return RemoteInterfaceValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteInterfaceValueUnknown() RemoteInterfaceValue {
	return RemoteInterfaceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteInterfaceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteInterfaceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteInterfaceValue Attribute Value",
				"While creating a RemoteInterfaceValue value, a missing attribute value was detected. "+
					"A RemoteInterfaceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteInterfaceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteInterfaceValue Attribute Type",
				"While creating a RemoteInterfaceValue value, an invalid attribute value was detected. "+
					"A RemoteInterfaceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteInterfaceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteInterfaceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteInterfaceValue Attribute Value",
				"While creating a RemoteInterfaceValue value, an extra attribute value was detected. "+
					"A RemoteInterfaceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteInterfaceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteInterfaceValueUnknown(), diags
	}

	defaultInterfaceAttribute, ok := attributes["default_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_interface is missing from object`)

		return NewRemoteInterfaceValueUnknown(), diags
	}

	defaultInterfaceVal, ok := defaultInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_interface expected to be basetypes.StringValue, was: %T`, defaultInterfaceAttribute))
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return NewRemoteInterfaceValueUnknown(), diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.StringValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return NewRemoteInterfaceValueUnknown(), diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.StringValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewRemoteInterfaceValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewRemoteInterfaceValueUnknown(), diags
	}

	return RemoteInterfaceValue{
		DefaultInterface: defaultInterfaceVal,
		Ipv4Address:      ipv4AddressVal,
		Ipv6Address:      ipv6AddressVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteInterfaceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteInterfaceValue {
	object, diags := NewRemoteInterfaceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteInterfaceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteInterfaceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteInterfaceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteInterfaceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteInterfaceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteInterfaceValueMust(RemoteInterfaceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteInterfaceType) ValueType(ctx context.Context) attr.Value {
	return RemoteInterfaceValue{}
}

var _ basetypes.ObjectValuable = RemoteInterfaceValue{}

type RemoteInterfaceValue struct {
	DefaultInterface basetypes.StringValue `tfsdk:"default_interface"`
	Ipv4Address      basetypes.StringValue `tfsdk:"ipv4_address"`
	Ipv6Address      basetypes.StringValue `tfsdk:"ipv6_address"`
	Node             basetypes.StringValue `tfsdk:"node"`
	state            attr.ValueState
}

func (v RemoteInterfaceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["default_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv4_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DefaultInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_interface"] = val

		val, err = v.Ipv4Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_address"] = val

		val, err = v.Ipv6Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_address"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteInterfaceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteInterfaceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteInterfaceValue) String() string {
	return "RemoteInterfaceValue"
}

func (v RemoteInterfaceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"default_interface": basetypes.StringType{},
		"ipv4_address":      basetypes.StringType{},
		"ipv6_address":      basetypes.StringType{},
		"node":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_interface": v.DefaultInterface,
			"ipv4_address":      v.Ipv4Address,
			"ipv6_address":      v.Ipv6Address,
			"node":              v.Node,
		})

	return objVal, diags
}

func (v RemoteInterfaceValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteInterfaceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultInterface.Equal(other.DefaultInterface) {
		return false
	}

	if !v.Ipv4Address.Equal(other.Ipv4Address) {
		return false
	}

	if !v.Ipv6Address.Equal(other.Ipv6Address) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v RemoteInterfaceValue) Type(ctx context.Context) attr.Type {
	return RemoteInterfaceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteInterfaceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_interface": basetypes.StringType{},
		"ipv4_address":      basetypes.StringType{},
		"ipv6_address":      basetypes.StringType{},
		"node":              basetypes.StringType{},
	}
}
