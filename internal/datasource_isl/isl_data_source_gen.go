// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_isl

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func IslDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"hash": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "resource content will be returned as it was at the time of this git hash",
				MarkdownDescription: "resource content will be returned as it was at the time of this git hash",
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "name of the ISL",
				MarkdownDescription: "name of the ISL",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bfd": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"desired_min_transmit_int": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval in microseconds between transmission of BFD control packets.",
								MarkdownDescription: "The minimum interval in microseconds between transmission of BFD control packets.",
							},
							"detection_multiplier": schema.Int64Attribute{
								Optional:            true,
								Description:         "The number of packets that must be missed to declare this session as down.",
								MarkdownDescription: "The number of packets that must be missed to declare this session as down.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable Biforward Detection.",
								MarkdownDescription: "Enable Biforward Detection.",
							},
							"min_echo_receive_interval": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval between echo packets the local node can receive in microseconds.",
								MarkdownDescription: "The minimum interval between echo packets the local node can receive in microseconds.",
							},
							"required_min_receive": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval in microseconds between received BFD control packets that this system should support.",
								MarkdownDescription: "The minimum interval in microseconds between received BFD control packets that this system should support.",
							},
							"ttl": schema.Int64Attribute{
								Optional:            true,
								Description:         "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
								MarkdownDescription: "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
							},
						},
						CustomType: BfdType{
							ObjectType: types.ObjectType{
								AttrTypes: BfdValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Enable or disable BFD on the ISL. [default=false]",
						MarkdownDescription: "Enable or disable BFD on the ISL. [default=false]",
					},
					"bgp": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"afi_safi": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Which AFI and SAFI to advertise on the BGP peering session. Options: ipv4unicast, ipv6unicast, l2vpnevpn",
								MarkdownDescription: "Which AFI and SAFI to advertise on the BGP peering session. Options: ipv4unicast, ipv6unicast, l2vpnevpn",
							},
							"bgp_group": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to a DefaultBgpGroup.",
								MarkdownDescription: "Reference to a DefaultBgpGroup.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable or disable BGP peering between the two endpoints of the ISL. [default=false]",
								MarkdownDescription: "Enable or disable BGP peering between the two endpoints of the ISL. [default=false]",
							},
							"export_policy": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Reference to a RoutingPolicy to use when evaluating route exports from the DefaultRouter.",
								MarkdownDescription: "Reference to a RoutingPolicy to use when evaluating route exports from the DefaultRouter.",
							},
							"import_policy": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Reference to a RoutingPolicy to use when evaluating route imports into the DefaultRouter.",
								MarkdownDescription: "Reference to a RoutingPolicy to use when evaluating route imports into the DefaultRouter.",
							},
							"keychain": schema.StringAttribute{
								Optional:            true,
								Description:         "Keychain to be used for authentication",
								MarkdownDescription: "Keychain to be used for authentication",
							},
							"local_interface_as": schema.Int64Attribute{
								Optional:            true,
								Description:         "The Autonomous System to configure on the Local Interface.",
								MarkdownDescription: "The Autonomous System to configure on the Local Interface.",
							},
							"remote_interface_as": schema.Int64Attribute{
								Optional:            true,
								Description:         "The Autonomous System to configure on the Remote Interface.",
								MarkdownDescription: "The Autonomous System to configure on the Remote Interface.",
							},
						},
						CustomType: BgpType{
							ObjectType: types.ObjectType{
								AttrTypes: BgpValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"ip_mtu": schema.Int64Attribute{
						Optional:            true,
						Description:         "Sets the IP MTU for the local and remote Interfaces",
						MarkdownDescription: "Sets the IP MTU for the local and remote Interfaces",
					},
					"local_default_router": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to the DefautlRouter associated with the local Interface in which the ISL will be provisioned.",
						MarkdownDescription: "Reference to the DefautlRouter associated with the local Interface in which the ISL will be provisioned.",
					},
					"local_interface": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an Interface.",
						MarkdownDescription: "Reference to an Interface.",
					},
					"pool_ipv4": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an IPv4 allocation pool to use for ISL subnet allocations.",
						MarkdownDescription: "Reference to an IPv4 allocation pool to use for ISL subnet allocations.",
					},
					"pool_ipv6": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an IPv6 allocation pool to use for ISL subnet allocations.",
						MarkdownDescription: "Reference to an IPv6 allocation pool to use for ISL subnet allocations.",
					},
					"qos": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"egress_policy": schema.StringAttribute{
								Optional: true,
							},
							"ingress_policy": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: QosType{
							ObjectType: types.ObjectType{
								AttrTypes: QosValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"remote_default_router": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to the DefautlRouter associated with the remote Interface in which the ISL will be provisioned.",
						MarkdownDescription: "Reference to the DefautlRouter associated with the remote Interface in which the ISL will be provisioned.",
					},
					"remote_interface": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an Interface",
						MarkdownDescription: "Reference to an Interface",
					},
					"unnumbered": schema.StringAttribute{
						Optional:            true,
						Description:         "Enables the use of unnumbered interfaces on the ISL. For IPv6, no IP address are configured on the sub-interface and only the link local address will be used. If any allocation pool is specified for IPv6 that will take precedence and IPs will be assigned to the interfaces.  When using eBGP for an underlay protocol, the DefaultInterfaces which are a part of the ISL will be added to the BGP dynamic neighbor list.",
						MarkdownDescription: "Enables the use of unnumbered interfaces on the ISL. For IPv6, no IP address are configured on the sub-interface and only the link local address will be used. If any allocation pool is specified for IPv6 that will take precedence and IPs will be assigned to the interfaces.  When using eBGP for an underlay protocol, the DefaultInterfaces which are a part of the ISL will be added to the BGP dynamic neighbor list.",
					},
					"vlan_id": schema.Int64Attribute{
						Optional:            true,
						Description:         "Single VLAN tag value between 1-4094.",
						MarkdownDescription: "Single VLAN tag value between 1-4094.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "The ISL enables the configuration and management of direct links between Nodes. This resource allows for specifying IPv4 and IPv6 allocation pools, enabling BFD for fast failure detection, and configuring VLAN IDs for the ISL. It also supports BGP peering between the endpoints, with options for setting autonomous systems, AFI/SAFI configurations, and import/export routing policies.",
				MarkdownDescription: "The ISL enables the configuration and management of direct links between Nodes. This resource allows for specifying IPv4 and IPv6 allocation pools, enabling BFD for fast failure detection, and configuring VLAN IDs for the ISL. It also supports BGP peering between the endpoints, with options for setting autonomous systems, AFI/SAFI configurations, and import/export routing policies.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"health": schema.Int64Attribute{
						Computed:            true,
						Description:         "Indicates the health score of the ISL",
						MarkdownDescription: "Indicates the health score of the ISL",
					},
					"health_score_reason": schema.StringAttribute{
						Computed:            true,
						Description:         "Indicates the reason for the health score",
						MarkdownDescription: "Indicates the reason for the health score",
					},
					"last_change": schema.StringAttribute{
						Computed:            true,
						Description:         "The time when the state of the resource last changed",
						MarkdownDescription: "The time when the state of the resource last changed",
					},
					"local_interface": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"default_interface": schema.StringAttribute{
								Computed:            true,
								Description:         "Reference to the DefaulInterface assocaited with the local interface",
								MarkdownDescription: "Reference to the DefaulInterface assocaited with the local interface",
							},
							"ipv4_address": schema.StringAttribute{
								Computed:            true,
								Description:         "Local Interface IPv4 address",
								MarkdownDescription: "Local Interface IPv4 address",
							},
							"ipv6_address": schema.StringAttribute{
								Computed:            true,
								Description:         "Local Interface IPv4 address",
								MarkdownDescription: "Local Interface IPv4 address",
							},
							"node": schema.StringAttribute{
								Computed:            true,
								Description:         "Reference to the TopoNode on which the local interface is configured",
								MarkdownDescription: "Reference to the TopoNode on which the local interface is configured",
							},
						},
						CustomType: LocalInterfaceType{
							ObjectType: types.ObjectType{
								AttrTypes: LocalInterfaceValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Local Interface",
						MarkdownDescription: "Local Interface",
					},
					"operational_state": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational state of the ISL",
						MarkdownDescription: "Operational state of the ISL",
					},
					"remote_interface": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"default_interface": schema.StringAttribute{
								Computed:            true,
								Description:         "Reference to the DefaulInterface assocaited with the remote interface",
								MarkdownDescription: "Reference to the DefaulInterface assocaited with the remote interface",
							},
							"ipv4_address": schema.StringAttribute{
								Computed:            true,
								Description:         "Remote Interface IPv4 address",
								MarkdownDescription: "Remote Interface IPv4 address",
							},
							"ipv6_address": schema.StringAttribute{
								Computed:            true,
								Description:         "Remote Interface IPv6 address",
								MarkdownDescription: "Remote Interface IPv6 address",
							},
							"node": schema.StringAttribute{
								Computed:            true,
								Description:         "Reference to the TopoNode on which the remote interface is configured",
								MarkdownDescription: "Reference to the TopoNode on which the remote interface is configured",
							},
						},
						CustomType: RemoteInterfaceType{
							ObjectType: types.ObjectType{
								AttrTypes: RemoteInterfaceValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Remote Interface",
						MarkdownDescription: "Remote Interface",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "ISLStatus defines the observed state of ISL",
				MarkdownDescription: "ISLStatus defines the observed state of ISL",
			},
		},
	}
}

type IslModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Hash       types.String  `tfsdk:"hash"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return nil, diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	localDefaultRouterAttribute, ok := attributes["local_default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_default_router is missing from object`)

		return nil, diags
	}

	localDefaultRouterVal, ok := localDefaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_default_router expected to be basetypes.StringValue, was: %T`, localDefaultRouterAttribute))
	}

	localInterfaceAttribute, ok := attributes["local_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface is missing from object`)

		return nil, diags
	}

	localInterfaceVal, ok := localInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface expected to be basetypes.StringValue, was: %T`, localInterfaceAttribute))
	}

	poolIpv4Attribute, ok := attributes["pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv4 is missing from object`)

		return nil, diags
	}

	poolIpv4Val, ok := poolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv4 expected to be basetypes.StringValue, was: %T`, poolIpv4Attribute))
	}

	poolIpv6Attribute, ok := attributes["pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv6 is missing from object`)

		return nil, diags
	}

	poolIpv6Val, ok := poolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv6 expected to be basetypes.StringValue, was: %T`, poolIpv6Attribute))
	}

	qosAttribute, ok := attributes["qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos is missing from object`)

		return nil, diags
	}

	qosVal, ok := qosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos expected to be basetypes.ObjectValue, was: %T`, qosAttribute))
	}

	remoteDefaultRouterAttribute, ok := attributes["remote_default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_default_router is missing from object`)

		return nil, diags
	}

	remoteDefaultRouterVal, ok := remoteDefaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_default_router expected to be basetypes.StringValue, was: %T`, remoteDefaultRouterAttribute))
	}

	remoteInterfaceAttribute, ok := attributes["remote_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface is missing from object`)

		return nil, diags
	}

	remoteInterfaceVal, ok := remoteInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface expected to be basetypes.StringValue, was: %T`, remoteInterfaceAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return nil, diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Bfd:                 bfdVal,
		Bgp:                 bgpVal,
		IpMtu:               ipMtuVal,
		LocalDefaultRouter:  localDefaultRouterVal,
		LocalInterface:      localInterfaceVal,
		PoolIpv4:            poolIpv4Val,
		PoolIpv6:            poolIpv6Val,
		Qos:                 qosVal,
		RemoteDefaultRouter: remoteDefaultRouterVal,
		RemoteInterface:     remoteInterfaceVal,
		Unnumbered:          unnumberedVal,
		VlanId:              vlanIdVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	localDefaultRouterAttribute, ok := attributes["local_default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_default_router is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	localDefaultRouterVal, ok := localDefaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_default_router expected to be basetypes.StringValue, was: %T`, localDefaultRouterAttribute))
	}

	localInterfaceAttribute, ok := attributes["local_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	localInterfaceVal, ok := localInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface expected to be basetypes.StringValue, was: %T`, localInterfaceAttribute))
	}

	poolIpv4Attribute, ok := attributes["pool_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv4 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	poolIpv4Val, ok := poolIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv4 expected to be basetypes.StringValue, was: %T`, poolIpv4Attribute))
	}

	poolIpv6Attribute, ok := attributes["pool_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pool_ipv6 is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	poolIpv6Val, ok := poolIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pool_ipv6 expected to be basetypes.StringValue, was: %T`, poolIpv6Attribute))
	}

	qosAttribute, ok := attributes["qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	qosVal, ok := qosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos expected to be basetypes.ObjectValue, was: %T`, qosAttribute))
	}

	remoteDefaultRouterAttribute, ok := attributes["remote_default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_default_router is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	remoteDefaultRouterVal, ok := remoteDefaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_default_router expected to be basetypes.StringValue, was: %T`, remoteDefaultRouterAttribute))
	}

	remoteInterfaceAttribute, ok := attributes["remote_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	remoteInterfaceVal, ok := remoteInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface expected to be basetypes.StringValue, was: %T`, remoteInterfaceAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Bfd:                 bfdVal,
		Bgp:                 bgpVal,
		IpMtu:               ipMtuVal,
		LocalDefaultRouter:  localDefaultRouterVal,
		LocalInterface:      localInterfaceVal,
		PoolIpv4:            poolIpv4Val,
		PoolIpv6:            poolIpv6Val,
		Qos:                 qosVal,
		RemoteDefaultRouter: remoteDefaultRouterVal,
		RemoteInterface:     remoteInterfaceVal,
		Unnumbered:          unnumberedVal,
		VlanId:              vlanIdVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Bfd                 basetypes.ObjectValue `tfsdk:"bfd"`
	Bgp                 basetypes.ObjectValue `tfsdk:"bgp"`
	IpMtu               basetypes.Int64Value  `tfsdk:"ip_mtu"`
	LocalDefaultRouter  basetypes.StringValue `tfsdk:"local_default_router"`
	LocalInterface      basetypes.StringValue `tfsdk:"local_interface"`
	PoolIpv4            basetypes.StringValue `tfsdk:"pool_ipv4"`
	PoolIpv6            basetypes.StringValue `tfsdk:"pool_ipv6"`
	Qos                 basetypes.ObjectValue `tfsdk:"qos"`
	RemoteDefaultRouter basetypes.StringValue `tfsdk:"remote_default_router"`
	RemoteInterface     basetypes.StringValue `tfsdk:"remote_interface"`
	Unnumbered          basetypes.StringValue `tfsdk:"unnumbered"`
	VlanId              basetypes.Int64Value  `tfsdk:"vlan_id"`
	state               attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: BfdValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: BgpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["local_default_router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pool_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pool_ipv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["qos"] = basetypes.ObjectType{
		AttrTypes: QosValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["remote_default_router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unnumbered"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Bgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.LocalDefaultRouter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_default_router"] = val

		val, err = v.LocalInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_interface"] = val

		val, err = v.PoolIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pool_ipv4"] = val

		val, err = v.PoolIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pool_ipv6"] = val

		val, err = v.Qos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos"] = val

		val, err = v.RemoteDefaultRouter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_default_router"] = val

		val, err = v.RemoteInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_interface"] = val

		val, err = v.Unnumbered.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unnumbered"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd basetypes.ObjectValue

	if v.Bfd.IsNull() {
		bfd = types.ObjectNull(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd.IsUnknown() {
		bfd = types.ObjectUnknown(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd.IsNull() && !v.Bfd.IsUnknown() {
		bfd = types.ObjectValueMust(
			BfdValue{}.AttributeTypes(ctx),
			v.Bfd.Attributes(),
		)
	}

	var bgp basetypes.ObjectValue

	if v.Bgp.IsNull() {
		bgp = types.ObjectNull(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp.IsUnknown() {
		bgp = types.ObjectUnknown(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp.IsNull() && !v.Bgp.IsUnknown() {
		bgp = types.ObjectValueMust(
			BgpValue{}.AttributeTypes(ctx),
			v.Bgp.Attributes(),
		)
	}

	var qos basetypes.ObjectValue

	if v.Qos.IsNull() {
		qos = types.ObjectNull(
			QosValue{}.AttributeTypes(ctx),
		)
	}

	if v.Qos.IsUnknown() {
		qos = types.ObjectUnknown(
			QosValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Qos.IsNull() && !v.Qos.IsUnknown() {
		qos = types.ObjectValueMust(
			QosValue{}.AttributeTypes(ctx),
			v.Qos.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"ip_mtu":               basetypes.Int64Type{},
		"local_default_router": basetypes.StringType{},
		"local_interface":      basetypes.StringType{},
		"pool_ipv4":            basetypes.StringType{},
		"pool_ipv6":            basetypes.StringType{},
		"qos": basetypes.ObjectType{
			AttrTypes: QosValue{}.AttributeTypes(ctx),
		},
		"remote_default_router": basetypes.StringType{},
		"remote_interface":      basetypes.StringType{},
		"unnumbered":            basetypes.StringType{},
		"vlan_id":               basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd":                   bfd,
			"bgp":                   bgp,
			"ip_mtu":                v.IpMtu,
			"local_default_router":  v.LocalDefaultRouter,
			"local_interface":       v.LocalInterface,
			"pool_ipv4":             v.PoolIpv4,
			"pool_ipv6":             v.PoolIpv6,
			"qos":                   qos,
			"remote_default_router": v.RemoteDefaultRouter,
			"remote_interface":      v.RemoteInterface,
			"unnumbered":            v.Unnumbered,
			"vlan_id":               v.VlanId,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.Bgp.Equal(other.Bgp) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.LocalDefaultRouter.Equal(other.LocalDefaultRouter) {
		return false
	}

	if !v.LocalInterface.Equal(other.LocalInterface) {
		return false
	}

	if !v.PoolIpv4.Equal(other.PoolIpv4) {
		return false
	}

	if !v.PoolIpv6.Equal(other.PoolIpv6) {
		return false
	}

	if !v.Qos.Equal(other.Qos) {
		return false
	}

	if !v.RemoteDefaultRouter.Equal(other.RemoteDefaultRouter) {
		return false
	}

	if !v.RemoteInterface.Equal(other.RemoteInterface) {
		return false
	}

	if !v.Unnumbered.Equal(other.Unnumbered) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"ip_mtu":               basetypes.Int64Type{},
		"local_default_router": basetypes.StringType{},
		"local_interface":      basetypes.StringType{},
		"pool_ipv4":            basetypes.StringType{},
		"pool_ipv6":            basetypes.StringType{},
		"qos": basetypes.ObjectType{
			AttrTypes: QosValue{}.AttributeTypes(ctx),
		},
		"remote_default_router": basetypes.StringType{},
		"remote_interface":      basetypes.StringType{},
		"unnumbered":            basetypes.StringType{},
		"vlan_id":               basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BfdType{}

type BfdType struct {
	basetypes.ObjectType
}

func (t BfdType) Equal(o attr.Type) bool {
	other, ok := o.(BfdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BfdType) String() string {
	return "BfdType"
}

func (t BfdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return nil, diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return nil, diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return nil, diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return nil, diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return nil, diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueNull() BfdValue {
	return BfdValue{
		state: attr.ValueStateNull,
	}
}

func NewBfdValueUnknown() BfdValue {
	return BfdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBfdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BfdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BfdValue Attribute Value",
				"While creating a BfdValue value, a missing attribute value was detected. "+
					"A BfdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BfdValue Attribute Type",
				"While creating a BfdValue value, an invalid attribute value was detected. "+
					"A BfdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BfdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BfdValue Attribute Value",
				"While creating a BfdValue value, an extra attribute value was detected. "+
					"A BfdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BfdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BfdValue {
	object, diags := NewBfdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BfdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfdValueMust(BfdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BfdType) ValueType(ctx context.Context) attr.Value {
	return BfdValue{}
}

var _ basetypes.ObjectValuable = BfdValue{}

type BfdValue struct {
	DesiredMinTransmitInt  basetypes.Int64Value `tfsdk:"desired_min_transmit_int"`
	DetectionMultiplier    basetypes.Int64Value `tfsdk:"detection_multiplier"`
	Enabled                basetypes.BoolValue  `tfsdk:"enabled"`
	MinEchoReceiveInterval basetypes.Int64Value `tfsdk:"min_echo_receive_interval"`
	RequiredMinReceive     basetypes.Int64Value `tfsdk:"required_min_receive"`
	Ttl                    basetypes.Int64Value `tfsdk:"ttl"`
	state                  attr.ValueState
}

func (v BfdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["desired_min_transmit_int"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["detection_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_echo_receive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required_min_receive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ttl"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DesiredMinTransmitInt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_min_transmit_int"] = val

		val, err = v.DetectionMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detection_multiplier"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MinEchoReceiveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_echo_receive_interval"] = val

		val, err = v.RequiredMinReceive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_min_receive"] = val

		val, err = v.Ttl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ttl"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BfdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BfdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BfdValue) String() string {
	return "BfdValue"
}

func (v BfdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"desired_min_transmit_int":  v.DesiredMinTransmitInt,
			"detection_multiplier":      v.DetectionMultiplier,
			"enabled":                   v.Enabled,
			"min_echo_receive_interval": v.MinEchoReceiveInterval,
			"required_min_receive":      v.RequiredMinReceive,
			"ttl":                       v.Ttl,
		})

	return objVal, diags
}

func (v BfdValue) Equal(o attr.Value) bool {
	other, ok := o.(BfdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DesiredMinTransmitInt.Equal(other.DesiredMinTransmitInt) {
		return false
	}

	if !v.DetectionMultiplier.Equal(other.DetectionMultiplier) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MinEchoReceiveInterval.Equal(other.MinEchoReceiveInterval) {
		return false
	}

	if !v.RequiredMinReceive.Equal(other.RequiredMinReceive) {
		return false
	}

	if !v.Ttl.Equal(other.Ttl) {
		return false
	}

	return true
}

func (v BfdValue) Type(ctx context.Context) attr.Type {
	return BfdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BfdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BgpType{}

type BgpType struct {
	basetypes.ObjectType
}

func (t BgpType) Equal(o attr.Type) bool {
	other, ok := o.(BgpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpType) String() string {
	return "BgpType"
}

func (t BgpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	afiSafiAttribute, ok := attributes["afi_safi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`afi_safi is missing from object`)

		return nil, diags
	}

	afiSafiVal, ok := afiSafiAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`afi_safi expected to be basetypes.ListValue, was: %T`, afiSafiAttribute))
	}

	bgpGroupAttribute, ok := attributes["bgp_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_group is missing from object`)

		return nil, diags
	}

	bgpGroupVal, ok := bgpGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_group expected to be basetypes.StringValue, was: %T`, bgpGroupAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	localInterfaceAsAttribute, ok := attributes["local_interface_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface_as is missing from object`)

		return nil, diags
	}

	localInterfaceAsVal, ok := localInterfaceAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface_as expected to be basetypes.Int64Value, was: %T`, localInterfaceAsAttribute))
	}

	remoteInterfaceAsAttribute, ok := attributes["remote_interface_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface_as is missing from object`)

		return nil, diags
	}

	remoteInterfaceAsVal, ok := remoteInterfaceAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface_as expected to be basetypes.Int64Value, was: %T`, remoteInterfaceAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpValue{
		AfiSafi:           afiSafiVal,
		BgpGroup:          bgpGroupVal,
		Enabled:           enabledVal,
		ExportPolicy:      exportPolicyVal,
		ImportPolicy:      importPolicyVal,
		Keychain:          keychainVal,
		LocalInterfaceAs:  localInterfaceAsVal,
		RemoteInterfaceAs: remoteInterfaceAsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBgpValueNull() BgpValue {
	return BgpValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpValueUnknown() BgpValue {
	return BgpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpValue Attribute Value",
				"While creating a BgpValue value, a missing attribute value was detected. "+
					"A BgpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpValue Attribute Type",
				"While creating a BgpValue value, an invalid attribute value was detected. "+
					"A BgpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpValue Attribute Value",
				"While creating a BgpValue value, an extra attribute value was detected. "+
					"A BgpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	afiSafiAttribute, ok := attributes["afi_safi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`afi_safi is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	afiSafiVal, ok := afiSafiAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`afi_safi expected to be basetypes.ListValue, was: %T`, afiSafiAttribute))
	}

	bgpGroupAttribute, ok := attributes["bgp_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_group is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	bgpGroupVal, ok := bgpGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_group expected to be basetypes.StringValue, was: %T`, bgpGroupAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	localInterfaceAsAttribute, ok := attributes["local_interface_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface_as is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	localInterfaceAsVal, ok := localInterfaceAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface_as expected to be basetypes.Int64Value, was: %T`, localInterfaceAsAttribute))
	}

	remoteInterfaceAsAttribute, ok := attributes["remote_interface_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface_as is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	remoteInterfaceAsVal, ok := remoteInterfaceAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface_as expected to be basetypes.Int64Value, was: %T`, remoteInterfaceAsAttribute))
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	return BgpValue{
		AfiSafi:           afiSafiVal,
		BgpGroup:          bgpGroupVal,
		Enabled:           enabledVal,
		ExportPolicy:      exportPolicyVal,
		ImportPolicy:      importPolicyVal,
		Keychain:          keychainVal,
		LocalInterfaceAs:  localInterfaceAsVal,
		RemoteInterfaceAs: remoteInterfaceAsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBgpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpValue {
	object, diags := NewBgpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpValueMust(BgpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpType) ValueType(ctx context.Context) attr.Value {
	return BgpValue{}
}

var _ basetypes.ObjectValuable = BgpValue{}

type BgpValue struct {
	AfiSafi           basetypes.ListValue   `tfsdk:"afi_safi"`
	BgpGroup          basetypes.StringValue `tfsdk:"bgp_group"`
	Enabled           basetypes.BoolValue   `tfsdk:"enabled"`
	ExportPolicy      basetypes.ListValue   `tfsdk:"export_policy"`
	ImportPolicy      basetypes.ListValue   `tfsdk:"import_policy"`
	Keychain          basetypes.StringValue `tfsdk:"keychain"`
	LocalInterfaceAs  basetypes.Int64Value  `tfsdk:"local_interface_as"`
	RemoteInterfaceAs basetypes.Int64Value  `tfsdk:"remote_interface_as"`
	state             attr.ValueState
}

func (v BgpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["afi_safi"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["bgp_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_interface_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_interface_as"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AfiSafi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["afi_safi"] = val

		val, err = v.BgpGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp_group"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.LocalInterfaceAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_interface_as"] = val

		val, err = v.RemoteInterfaceAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_interface_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpValue) String() string {
	return "BgpValue"
}

func (v BgpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var afiSafiVal basetypes.ListValue
	switch {
	case v.AfiSafi.IsUnknown():
		afiSafiVal = types.ListUnknown(types.StringType)
	case v.AfiSafi.IsNull():
		afiSafiVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		afiSafiVal, d = types.ListValue(types.StringType, v.AfiSafi.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"afi_safi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bgp_group": basetypes.StringType{},
			"enabled":   basetypes.BoolType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain":            basetypes.StringType{},
			"local_interface_as":  basetypes.Int64Type{},
			"remote_interface_as": basetypes.Int64Type{},
		}), diags
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"afi_safi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bgp_group": basetypes.StringType{},
			"enabled":   basetypes.BoolType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain":            basetypes.StringType{},
			"local_interface_as":  basetypes.Int64Type{},
			"remote_interface_as": basetypes.Int64Type{},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"afi_safi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bgp_group": basetypes.StringType{},
			"enabled":   basetypes.BoolType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"keychain":            basetypes.StringType{},
			"local_interface_as":  basetypes.Int64Type{},
			"remote_interface_as": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"afi_safi": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bgp_group": basetypes.StringType{},
		"enabled":   basetypes.BoolType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"keychain":            basetypes.StringType{},
		"local_interface_as":  basetypes.Int64Type{},
		"remote_interface_as": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"afi_safi":            afiSafiVal,
			"bgp_group":           v.BgpGroup,
			"enabled":             v.Enabled,
			"export_policy":       exportPolicyVal,
			"import_policy":       importPolicyVal,
			"keychain":            v.Keychain,
			"local_interface_as":  v.LocalInterfaceAs,
			"remote_interface_as": v.RemoteInterfaceAs,
		})

	return objVal, diags
}

func (v BgpValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AfiSafi.Equal(other.AfiSafi) {
		return false
	}

	if !v.BgpGroup.Equal(other.BgpGroup) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.LocalInterfaceAs.Equal(other.LocalInterfaceAs) {
		return false
	}

	if !v.RemoteInterfaceAs.Equal(other.RemoteInterfaceAs) {
		return false
	}

	return true
}

func (v BgpValue) Type(ctx context.Context) attr.Type {
	return BgpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"afi_safi": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bgp_group": basetypes.StringType{},
		"enabled":   basetypes.BoolType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"keychain":            basetypes.StringType{},
		"local_interface_as":  basetypes.Int64Type{},
		"remote_interface_as": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = QosType{}

type QosType struct {
	basetypes.ObjectType
}

func (t QosType) Equal(o attr.Type) bool {
	other, ok := o.(QosType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QosType) String() string {
	return "QosType"
}

func (t QosType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	egressPolicyAttribute, ok := attributes["egress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_policy is missing from object`)

		return nil, diags
	}

	egressPolicyVal, ok := egressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_policy expected to be basetypes.StringValue, was: %T`, egressPolicyAttribute))
	}

	ingressPolicyAttribute, ok := attributes["ingress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_policy is missing from object`)

		return nil, diags
	}

	ingressPolicyVal, ok := ingressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_policy expected to be basetypes.StringValue, was: %T`, ingressPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QosValue{
		EgressPolicy:  egressPolicyVal,
		IngressPolicy: ingressPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewQosValueNull() QosValue {
	return QosValue{
		state: attr.ValueStateNull,
	}
}

func NewQosValueUnknown() QosValue {
	return QosValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQosValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QosValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QosValue Attribute Value",
				"While creating a QosValue value, a missing attribute value was detected. "+
					"A QosValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QosValue Attribute Type",
				"While creating a QosValue value, an invalid attribute value was detected. "+
					"A QosValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QosValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QosValue Attribute Value",
				"While creating a QosValue value, an extra attribute value was detected. "+
					"A QosValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QosValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	egressPolicyAttribute, ok := attributes["egress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_policy is missing from object`)

		return NewQosValueUnknown(), diags
	}

	egressPolicyVal, ok := egressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_policy expected to be basetypes.StringValue, was: %T`, egressPolicyAttribute))
	}

	ingressPolicyAttribute, ok := attributes["ingress_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_policy is missing from object`)

		return NewQosValueUnknown(), diags
	}

	ingressPolicyVal, ok := ingressPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_policy expected to be basetypes.StringValue, was: %T`, ingressPolicyAttribute))
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	return QosValue{
		EgressPolicy:  egressPolicyVal,
		IngressPolicy: ingressPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewQosValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QosValue {
	object, diags := NewQosValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQosValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QosType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQosValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQosValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQosValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQosValueMust(QosValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QosType) ValueType(ctx context.Context) attr.Value {
	return QosValue{}
}

var _ basetypes.ObjectValuable = QosValue{}

type QosValue struct {
	EgressPolicy  basetypes.StringValue `tfsdk:"egress_policy"`
	IngressPolicy basetypes.StringValue `tfsdk:"ingress_policy"`
	state         attr.ValueState
}

func (v QosValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["egress_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ingress_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EgressPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress_policy"] = val

		val, err = v.IngressPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QosValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QosValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QosValue) String() string {
	return "QosValue"
}

func (v QosValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"egress_policy":  basetypes.StringType{},
		"ingress_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"egress_policy":  v.EgressPolicy,
			"ingress_policy": v.IngressPolicy,
		})

	return objVal, diags
}

func (v QosValue) Equal(o attr.Value) bool {
	other, ok := o.(QosValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EgressPolicy.Equal(other.EgressPolicy) {
		return false
	}

	if !v.IngressPolicy.Equal(other.IngressPolicy) {
		return false
	}

	return true
}

func (v QosValue) Type(ctx context.Context) attr.Type {
	return QosType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QosValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"egress_policy":  basetypes.StringType{},
		"ingress_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	localInterfaceAttribute, ok := attributes["local_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface is missing from object`)

		return nil, diags
	}

	localInterfaceVal, ok := localInterfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface expected to be basetypes.ObjectValue, was: %T`, localInterfaceAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	remoteInterfaceAttribute, ok := attributes["remote_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface is missing from object`)

		return nil, diags
	}

	remoteInterfaceVal, ok := remoteInterfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface expected to be basetypes.ObjectValue, was: %T`, remoteInterfaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		LocalInterface:    localInterfaceVal,
		OperationalState:  operationalStateVal,
		RemoteInterface:   remoteInterfaceVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	localInterfaceAttribute, ok := attributes["local_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_interface is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	localInterfaceVal, ok := localInterfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_interface expected to be basetypes.ObjectValue, was: %T`, localInterfaceAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	remoteInterfaceAttribute, ok := attributes["remote_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_interface is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	remoteInterfaceVal, ok := remoteInterfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_interface expected to be basetypes.ObjectValue, was: %T`, remoteInterfaceAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		LocalInterface:    localInterfaceVal,
		OperationalState:  operationalStateVal,
		RemoteInterface:   remoteInterfaceVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	LocalInterface    basetypes.ObjectValue `tfsdk:"local_interface"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	RemoteInterface   basetypes.ObjectValue `tfsdk:"remote_interface"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_interface"] = basetypes.ObjectType{
		AttrTypes: LocalInterfaceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_interface"] = basetypes.ObjectType{
		AttrTypes: RemoteInterfaceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.LocalInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_interface"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.RemoteInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_interface"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var localInterface basetypes.ObjectValue

	if v.LocalInterface.IsNull() {
		localInterface = types.ObjectNull(
			LocalInterfaceValue{}.AttributeTypes(ctx),
		)
	}

	if v.LocalInterface.IsUnknown() {
		localInterface = types.ObjectUnknown(
			LocalInterfaceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalInterface.IsNull() && !v.LocalInterface.IsUnknown() {
		localInterface = types.ObjectValueMust(
			LocalInterfaceValue{}.AttributeTypes(ctx),
			v.LocalInterface.Attributes(),
		)
	}

	var remoteInterface basetypes.ObjectValue

	if v.RemoteInterface.IsNull() {
		remoteInterface = types.ObjectNull(
			RemoteInterfaceValue{}.AttributeTypes(ctx),
		)
	}

	if v.RemoteInterface.IsUnknown() {
		remoteInterface = types.ObjectUnknown(
			RemoteInterfaceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RemoteInterface.IsNull() && !v.RemoteInterface.IsUnknown() {
		remoteInterface = types.ObjectValueMust(
			RemoteInterfaceValue{}.AttributeTypes(ctx),
			v.RemoteInterface.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"local_interface": basetypes.ObjectType{
			AttrTypes: LocalInterfaceValue{}.AttributeTypes(ctx),
		},
		"operational_state": basetypes.StringType{},
		"remote_interface": basetypes.ObjectType{
			AttrTypes: RemoteInterfaceValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"last_change":         v.LastChange,
			"local_interface":     localInterface,
			"operational_state":   v.OperationalState,
			"remote_interface":    remoteInterface,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.LocalInterface.Equal(other.LocalInterface) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.RemoteInterface.Equal(other.RemoteInterface) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"local_interface": basetypes.ObjectType{
			AttrTypes: LocalInterfaceValue{}.AttributeTypes(ctx),
		},
		"operational_state": basetypes.StringType{},
		"remote_interface": basetypes.ObjectType{
			AttrTypes: RemoteInterfaceValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = LocalInterfaceType{}

type LocalInterfaceType struct {
	basetypes.ObjectType
}

func (t LocalInterfaceType) Equal(o attr.Type) bool {
	other, ok := o.(LocalInterfaceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalInterfaceType) String() string {
	return "LocalInterfaceType"
}

func (t LocalInterfaceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultInterfaceAttribute, ok := attributes["default_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_interface is missing from object`)

		return nil, diags
	}

	defaultInterfaceVal, ok := defaultInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_interface expected to be basetypes.StringValue, was: %T`, defaultInterfaceAttribute))
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return nil, diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.StringValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return nil, diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.StringValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalInterfaceValue{
		DefaultInterface: defaultInterfaceVal,
		Ipv4Address:      ipv4AddressVal,
		Ipv6Address:      ipv6AddressVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalInterfaceValueNull() LocalInterfaceValue {
	return LocalInterfaceValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalInterfaceValueUnknown() LocalInterfaceValue {
	return LocalInterfaceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalInterfaceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalInterfaceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalInterfaceValue Attribute Value",
				"While creating a LocalInterfaceValue value, a missing attribute value was detected. "+
					"A LocalInterfaceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalInterfaceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalInterfaceValue Attribute Type",
				"While creating a LocalInterfaceValue value, an invalid attribute value was detected. "+
					"A LocalInterfaceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalInterfaceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalInterfaceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalInterfaceValue Attribute Value",
				"While creating a LocalInterfaceValue value, an extra attribute value was detected. "+
					"A LocalInterfaceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalInterfaceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalInterfaceValueUnknown(), diags
	}

	defaultInterfaceAttribute, ok := attributes["default_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_interface is missing from object`)

		return NewLocalInterfaceValueUnknown(), diags
	}

	defaultInterfaceVal, ok := defaultInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_interface expected to be basetypes.StringValue, was: %T`, defaultInterfaceAttribute))
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return NewLocalInterfaceValueUnknown(), diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.StringValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return NewLocalInterfaceValueUnknown(), diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.StringValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewLocalInterfaceValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewLocalInterfaceValueUnknown(), diags
	}

	return LocalInterfaceValue{
		DefaultInterface: defaultInterfaceVal,
		Ipv4Address:      ipv4AddressVal,
		Ipv6Address:      ipv6AddressVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalInterfaceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalInterfaceValue {
	object, diags := NewLocalInterfaceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalInterfaceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalInterfaceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalInterfaceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalInterfaceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalInterfaceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalInterfaceValueMust(LocalInterfaceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalInterfaceType) ValueType(ctx context.Context) attr.Value {
	return LocalInterfaceValue{}
}

var _ basetypes.ObjectValuable = LocalInterfaceValue{}

type LocalInterfaceValue struct {
	DefaultInterface basetypes.StringValue `tfsdk:"default_interface"`
	Ipv4Address      basetypes.StringValue `tfsdk:"ipv4_address"`
	Ipv6Address      basetypes.StringValue `tfsdk:"ipv6_address"`
	Node             basetypes.StringValue `tfsdk:"node"`
	state            attr.ValueState
}

func (v LocalInterfaceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["default_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv4_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DefaultInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_interface"] = val

		val, err = v.Ipv4Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_address"] = val

		val, err = v.Ipv6Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_address"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalInterfaceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalInterfaceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalInterfaceValue) String() string {
	return "LocalInterfaceValue"
}

func (v LocalInterfaceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"default_interface": basetypes.StringType{},
		"ipv4_address":      basetypes.StringType{},
		"ipv6_address":      basetypes.StringType{},
		"node":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_interface": v.DefaultInterface,
			"ipv4_address":      v.Ipv4Address,
			"ipv6_address":      v.Ipv6Address,
			"node":              v.Node,
		})

	return objVal, diags
}

func (v LocalInterfaceValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalInterfaceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultInterface.Equal(other.DefaultInterface) {
		return false
	}

	if !v.Ipv4Address.Equal(other.Ipv4Address) {
		return false
	}

	if !v.Ipv6Address.Equal(other.Ipv6Address) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v LocalInterfaceValue) Type(ctx context.Context) attr.Type {
	return LocalInterfaceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalInterfaceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_interface": basetypes.StringType{},
		"ipv4_address":      basetypes.StringType{},
		"ipv6_address":      basetypes.StringType{},
		"node":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteInterfaceType{}

type RemoteInterfaceType struct {
	basetypes.ObjectType
}

func (t RemoteInterfaceType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteInterfaceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteInterfaceType) String() string {
	return "RemoteInterfaceType"
}

func (t RemoteInterfaceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultInterfaceAttribute, ok := attributes["default_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_interface is missing from object`)

		return nil, diags
	}

	defaultInterfaceVal, ok := defaultInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_interface expected to be basetypes.StringValue, was: %T`, defaultInterfaceAttribute))
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return nil, diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.StringValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return nil, diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.StringValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteInterfaceValue{
		DefaultInterface: defaultInterfaceVal,
		Ipv4Address:      ipv4AddressVal,
		Ipv6Address:      ipv6AddressVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteInterfaceValueNull() RemoteInterfaceValue {
	return RemoteInterfaceValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteInterfaceValueUnknown() RemoteInterfaceValue {
	return RemoteInterfaceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteInterfaceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteInterfaceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteInterfaceValue Attribute Value",
				"While creating a RemoteInterfaceValue value, a missing attribute value was detected. "+
					"A RemoteInterfaceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteInterfaceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteInterfaceValue Attribute Type",
				"While creating a RemoteInterfaceValue value, an invalid attribute value was detected. "+
					"A RemoteInterfaceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteInterfaceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteInterfaceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteInterfaceValue Attribute Value",
				"While creating a RemoteInterfaceValue value, an extra attribute value was detected. "+
					"A RemoteInterfaceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteInterfaceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteInterfaceValueUnknown(), diags
	}

	defaultInterfaceAttribute, ok := attributes["default_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_interface is missing from object`)

		return NewRemoteInterfaceValueUnknown(), diags
	}

	defaultInterfaceVal, ok := defaultInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_interface expected to be basetypes.StringValue, was: %T`, defaultInterfaceAttribute))
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return NewRemoteInterfaceValueUnknown(), diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.StringValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return NewRemoteInterfaceValueUnknown(), diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.StringValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewRemoteInterfaceValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewRemoteInterfaceValueUnknown(), diags
	}

	return RemoteInterfaceValue{
		DefaultInterface: defaultInterfaceVal,
		Ipv4Address:      ipv4AddressVal,
		Ipv6Address:      ipv6AddressVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteInterfaceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteInterfaceValue {
	object, diags := NewRemoteInterfaceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteInterfaceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteInterfaceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteInterfaceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteInterfaceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteInterfaceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteInterfaceValueMust(RemoteInterfaceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteInterfaceType) ValueType(ctx context.Context) attr.Value {
	return RemoteInterfaceValue{}
}

var _ basetypes.ObjectValuable = RemoteInterfaceValue{}

type RemoteInterfaceValue struct {
	DefaultInterface basetypes.StringValue `tfsdk:"default_interface"`
	Ipv4Address      basetypes.StringValue `tfsdk:"ipv4_address"`
	Ipv6Address      basetypes.StringValue `tfsdk:"ipv6_address"`
	Node             basetypes.StringValue `tfsdk:"node"`
	state            attr.ValueState
}

func (v RemoteInterfaceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["default_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv4_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DefaultInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_interface"] = val

		val, err = v.Ipv4Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_address"] = val

		val, err = v.Ipv6Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_address"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteInterfaceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteInterfaceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteInterfaceValue) String() string {
	return "RemoteInterfaceValue"
}

func (v RemoteInterfaceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"default_interface": basetypes.StringType{},
		"ipv4_address":      basetypes.StringType{},
		"ipv6_address":      basetypes.StringType{},
		"node":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_interface": v.DefaultInterface,
			"ipv4_address":      v.Ipv4Address,
			"ipv6_address":      v.Ipv6Address,
			"node":              v.Node,
		})

	return objVal, diags
}

func (v RemoteInterfaceValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteInterfaceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultInterface.Equal(other.DefaultInterface) {
		return false
	}

	if !v.Ipv4Address.Equal(other.Ipv4Address) {
		return false
	}

	if !v.Ipv6Address.Equal(other.Ipv6Address) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v RemoteInterfaceValue) Type(ctx context.Context) attr.Type {
	return RemoteInterfaceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteInterfaceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_interface": basetypes.StringType{},
		"ipv4_address":      basetypes.StringType{},
		"ipv6_address":      basetypes.StringType{},
		"node":              basetypes.StringType{},
	}
}
